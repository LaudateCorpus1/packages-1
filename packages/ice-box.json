{
  "name": "ice-box",
  "version": "0.1.0",
  "description": "Create unique, write-once, immutable directories.",
  "main": "index.js",
  "scripts": {
    "test": "standard *.js examples/* && tape test/*"
  },
  "keywords": [
    "immutable",
    "frozen",
    "write-once",
    "read-only",
    "read only",
    "unique",
    "pipe",
    "directory"
  ],
  "author": {
    "name": "Stephen Whitmore",
    "email": "stephen.whitmore@gmail.com"
  },
  "license": "ISC",
  "dependencies": {
    "fs-extra": "^0.30.0",
    "guid": "0.0.12",
    "mkdirp": "^0.5.1",
    "mv": "^2.1.1",
    "octal": "^1.0.0",
    "walk": "^2.3.9"
  },
  "devDependencies": {
    "standard": "^8.3.0",
    "tape": "^4.6.2"
  },
  "gitHead": "c3e2aa9d03a36eaf23a331c43d67baf6739a49fb",
  "_npmVersion": "3.10.7",
  "_nodeVersion": "6.5.0",
  "dist": {
    "shasum": "0454f29fe8c6a96be0b8fa9fdceeaf5aee75a7c8",
    "tarball": "http://registry.npmjs.org/ice-box/-/ice-box-0.1.0.tgz"
  },
  "versions": [
    {
      "number": "0.0.1",
      "date": "2016-10-02T00:10:22.511Z"
    },
    {
      "number": "0.0.2",
      "date": "2016-10-02T21:25:15.037Z"
    },
    {
      "number": "0.0.3",
      "date": "2016-10-02T21:25:44.304Z"
    },
    {
      "number": "0.1.0",
      "date": "2016-10-03T01:34:13.579Z"
    }
  ],
  "created": "2016-10-02T00:10:22.511Z",
  "modified": "2016-10-03T01:34:13.579Z",
  "lastPublisher": {
    "name": "noffle",
    "email": "stephen.whitmore@gmail.com"
  },
  "owners": [
    {
      "name": "noffle",
      "email": "stephen.whitmore@gmail.com"
    }
  ],
  "readme": "# ice-box\n\n> easy, one-off immutable directories!\n\n[Pure functions]() are a powerful concept. They allow you to, given an input,\nproduce the same deterministic output, *without side effects*.\n\nOn the filesystem, this is hard to achieve. Filesystems are all about side\neffects! Consider creating a directory as a function, and then creating a file\nwithin it:\n\n```sh\n$ mkdir foobar\n\n$ touch foobar/quux\n```\n\nIf this was part of a script you used in, say, a build process, you might run\ninto some problems:\n\n1. your current directory is an implicit input; being in the wrong directory\n   will have unintended side effects.\n2. `mkdir foobar` is not\n   [idempotent](https://en.wikipedia.org/wiki/Idempotence): multiple\n   applications of it in the same directory yield different results (generally,\n   an error).\n3. it creates *global mutable state*. what if another not-quite-pure function\n   decided it wanted to use `foobar/quux` for a different purpose? Each script\n   can clobber and conflict with the other!\n4. the resultant folder can be modified between functions. If I ran `mkdir foo;\n   sleep 10; touch foo/quux` and, during those 10 seconds, another process did\n   `rm -rf foo`, the result would be different than if they hadn't.\n\nFrom this, we can say that a better solution would have the three inverse\nproperties:\n\n1. the current directory should be irrelevant (that is, all paths should be\n   absolute).\n2. each application of a function should produce a brand new folder.\n3. each brand new folder should be unique named, to prevent conflicts.\n4. each brand new folder should have write permissions removed, so that its\n   contents are frozen.\n\nEnter **ice-box**: a module that manages a store of uniquely-named, immutable\ndirectories, and makes it easy to create new ones.\n\n## Usage\n\nLet's say we have a build system that takes a directory and puts its contents\ninto a tarball. What might a script look like to do that, so we could invoke it\nusing `node make-tar.js some-directory/`?\n\n```js\nvar icebox = require('ice-box')()\nvar fs = require('fs')\nvar path = require('path')\nvar tar = require('tar-fs')\n\nvar src = process.argv[2]\n\nicebox(function (dst, done) {\n  tar\n    .pack(src)\n    .pipe(fs.createWriteStream(path.join(dst, 'result.tar')))\n    .on('finish', done)\n}, function (err, finalDir) {\n  console.log(finalDir)\n})\n```\n\nRunning `node make-tar.js some-directory/` will output\n\n```\n/home/sww/ice-box/8755ce4b-9ab0-c667-ea28-1f36bd0c8512\n```\n\nwhich contains the output file, `result.tar`.\n\n## Pipelines\n\nMuch like UNIX pipes, this enables the creation of UNIX-like pipes: programs\nthat consume a directory can produce a new immutable directory and output that.\n\nImagine we had a program that took a directory of JS files and packaged them for\n[Electron](http://electron.atom.io/) before the tarball step:\n\n```js\nvar icebox = require('ice-box')('./ice-box')\n\nvar packager = require('electron-packager')\n\nvar src = process.argv[2]\n\nicebox(function (dst, done) {\n  packager({\n    dir: src,  // use the input dir, 'src'\n    arch: 'x64',\n    platform: 'linux',\n    out: dst,  // use the output dir, 'dst'\n    tmpdir: false,\n    prune: true,\n    overwrite: true,\n  }, done)\n}, function (err, finalDir) {\n  console.log(finalDir)\n})\n```\n\nNow we could run this as just\n\n```sh\n$ node build-electron.js .\n\n/home/sww/ice-box/8e3a47f8-f91d-a70b-692f-d0f54b730fb2\n```\n\nto get the electron-ready output, *or* it can be piped into `make-tar.js` from\nthe above section to produce the final `.tar` file!\n\n```sh\n$ node build-electron.js . | node make-tar.js\n\n/home/sww/ice-box/a5339569-ae8f-4430-2dc1-a1a55340ea67\n```\n\nNow we have a directory with a tarball of the electron package!\n\n*Bonus*: all intermediate steps are permanently cacheable, since they're\nimmutable and permanent!\n\n\n## API\n\n```js\nvar iceBox = require('ice-box')\n```\n\n### var icebox = iceBox([outDir], [tmpDir])\n\nCreates a new function for adding new directories to an icebox. Both parameters\nare optional, and default to sane values.\n\n- `outDir` (string) - The location to place the immutable output directories.\n  Defaults to `./ice-box`.\n- `tmpDir` (string) - The temporary location to create in-progress directories\n  that haven't yet finished being produced. These are cleaned up once they are\n  frozen and placed in `outDir`.\n\n### icebox(work, done)\n\nCreates a new directory for writing to.\n\n`work` is a function of the form `function (dir, done) { ... }`. `dir` is the\nabsolute path to the in-progress temporary directory. It has full write\npermissions. `done` is a function to call once you are done writing, to signify\nthat the directory can be \"frozen\" and placed in the icebox. If you pass in an\nerror (`done(err)`) then the entire operation will abort cleanly.\n\n`done` is a function of the form `function (dir) { ... }`. It is called once the\nnewly-frozen output directory is placed in the ice-box (`outDir` from the above\nsection). `path` is a string containing the absolute path to the frozen,\nimmutable, unique directory.\n\n\n## Install\n\nWith [npm](https://npmjs.org/) installed, run\n\n```\n$ npm install ice-box\n```\n\n## Acknowledgments\n\nI was inspired by looking at how many codebases will use a many-step build\nprocess that involves transforming directories (source dir -> build dir ->\npackaged dir -> windows installer program), but suffer from side effects and\nshared global state. If build steps were interrupted the series of output\ndirectories would be inconsistent, hard to track down, etc. I really wanted to\nbe able to make build and release pipelines that were as easy to reason about as\nUNIX pipes.\n\n## See Also\n\n- [`noffle/common-readme`](https://github.com/noffle/common-readme)\n\n## License\n\nISC\n"
}