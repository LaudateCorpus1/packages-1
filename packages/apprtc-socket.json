{
  "name": "apprtc-socket",
  "version": "0.2.3",
  "description": "Socket for transferring messages via the AppRtc WebSocket server",
  "main": "index.js",
  "keywords": [
    "apprtc",
    "websocket",
    "client"
  ],
  "author": {
    "name": "Nico Janssens",
    "email": "nico.b.janssens@gmail.com"
  },
  "license": "MIT",
  "engines": {
    "node": ">=4.x.x"
  },
  "dependencies": {
    "debug": "^2.2.0",
    "q": "^1.4.1",
    "websocket": "^1.0.22"
  },
  "devDependencies": {
    "browserify": "^13.1.0",
    "chai": "^3.5.0",
    "electron-prebuilt": "^1.3.2",
    "hat": "0.0.3",
    "mocha": "^2.4.4",
    "publish": "^0.6.0",
    "uglify-js": "^2.7.0",
    "zuul": "^3.10.3"
  },
  "repository": {
    "user": "nicojanssens",
    "repo": "apprtc-socket-js",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/nicojanssens/apprtc-socket-js/tarball/master",
    "clone_url": "https://github.com/nicojanssens/apprtc-socket-js",
    "https_url": "https://github.com/nicojanssens/apprtc-socket-js",
    "travis_url": "https://travis-ci.org/nicojanssens/apprtc-socket-js",
    "zip_url": "https://github.com/nicojanssens/apprtc-socket-js/archive/master.zip",
    "api_url": "https://api.github.com/repos/nicojanssens/apprtc-socket-js"
  },
  "scripts": {
    "build": "browserify -s AppRtcSocket -e ./ | uglifyjs -c warnings=false -m > apprtc-socket.min.js",
    "build-debug": "browserify -s AppRtcSocket -e ./ > apprtc-socket.debug.js",
    "size": "npm run build && cat apprtc-socket.min.js | gzip | wc -c",
    "test-browser": "zuul -- test/*.unit.js",
    "test-browser-local": "zuul --local -- test/*.unit.js",
    "test-browser-headless": "zuul --electron -- test/*.unit.js",
    "test-node": "mocha test/*.unit.js",
    "clean": "rm -f apprtc-socket.*.js && rm -rf node_modules",
    "2npm": "publish"
  },
  "homepage": "https://github.com/nicojanssens/apprtc-socket-js#readme",
  "_npmVersion": "2.15.9",
  "_nodeVersion": "4.4.5",
  "dist": {
    "shasum": "94e6194c909f9ab6912e879979dbcad44b237abd",
    "tarball": "http://registry.npmjs.org/apprtc-socket/-/apprtc-socket-0.2.3.tgz"
  },
  "versions": [
    {
      "number": "0.0.1",
      "date": "2016-01-28T21:50:33.428Z"
    },
    {
      "number": "0.1.0",
      "date": "2016-02-03T14:40:31.945Z"
    },
    {
      "number": "0.1.1",
      "date": "2016-03-03T15:46:05.180Z"
    },
    {
      "number": "0.1.2",
      "date": "2016-07-22T09:40:34.118Z"
    },
    {
      "number": "0.1.3",
      "date": "2016-07-22T17:37:13.494Z"
    },
    {
      "number": "0.1.4",
      "date": "2016-07-23T17:47:22.074Z"
    },
    {
      "number": "0.2.0",
      "date": "2016-08-09T08:38:57.379Z"
    },
    {
      "number": "0.2.1",
      "date": "2016-08-09T09:34:35.366Z"
    },
    {
      "number": "0.2.2",
      "date": "2016-08-09T20:48:09.472Z"
    },
    {
      "number": "0.2.3",
      "date": "2016-08-11T19:15:34.780Z"
    }
  ],
  "created": "2016-01-28T21:50:33.428Z",
  "modified": "2016-08-11T19:15:34.780Z",
  "lastPublisher": {
    "name": "nicoj",
    "email": "nico.b.janssens@gmail.com"
  },
  "owners": [
    {
      "name": "nicoj",
      "email": "nico.b.janssens@gmail.com"
    }
  ],
  "readme": "[![CircleCI](https://circleci.com/gh/nicojanssens/apprtc-socket-js.svg?style=shield)](https://circleci.com/gh/nicojanssens/apprtc-socket-js)\n[![npm](https://img.shields.io/npm/v/apprtc-socket.svg)](https://npmjs.org/package/apprtc-socket)\n\n# AppRtc Socket\n\n## Summary\nSocket using the AppRtc WebSocket server to exchange messages between *two* peers. This socket is developed to exchange lightweight signaling messages, *not* for transmitting (large) binaries.\n\n## Features\n- supports text message exchange between two peers identified by a unique key\n- offers callback and promise based API\n- can be browserified\n\n## Install\n```\nnpm install apprtc-socket\n```\n\n## Usage\n\n### Callbacks\n```js\nvar socket = require('apprtc-socket')\n\nvar myId = 'foo' // replace with unique key\nvar peerId = 'bar' // replace with unique key\n\nvar mySocket = socket(myId, peerId)\n// socket is connected and ready to use\nmySocket.on('ready', function() {\n  // send text message to peer\n  mySocket.send('test message')\n  // close socket\n  mySocket.close()\n})\nmySocket.on('message', function(message) {\n  // incoming text message\n})\nmySocket.on('close', function() {\n  // socket is closed\n})\nmySocket.on('error', function(error) {\n  // ooops\n})\n\n// activate the connection\nmySocket.connect()\n```\n\n### Promises\n```js\nvar socket = require('apprtc-socket')\n\nvar myId = 'foo' // replace with unique key\nvar peerId = 'bar' // replace with unique key\n\nvar mySocket = socket(myId, peerId)\nmySocket.on('message', function(message) {\n  // incoming text message\n})\nmySocket.on('error', function(error) {\n  // ooops\n})\n\n// activate the connection\nmySocket.connectP()\n  // socket is connected and ready to use\n  .then(function () {\n    // send text message to peer\n    mySocket.send('test message')\n    // close socket\n    return mySocket.closeP()\n  })\n  .then(function () {\n    // socket is closed\n  })\n  .catch(function (error) {\n    // ooops\n  })\n```\n\n## API\n\n### `var mySocket = socket(myId, peerId)`\nCreate a new AppRtcSocket connection. Both interacting peers must be identified by a unique key.\n\n### `mySocket.connect()`\nConnect to the AppRtc WebSocket server and register a connection. The id of the AppRtc room that both peers use to exchange messages is a commutative hash calculated from both peers' unique keys. This function fires a `ready` event once the registration succeeds.\n\n### `mySocket.connectP()`\nConnect to the AppRtc WebSocket server and register a connection. Instead of firing a `ready` event, this function returns a promise that gets fulfilled once the registration succeeds.\n\n### `mySocket.send(data)`\nSend text data to the connected peer. `data` should be of type\n`String`, other data types can be transformed into a `String` with `JSON.stringify`.\n\n### `mySocket.close()`\nClose a connection. Fires a `close` event once complete.\n\n### `mySocket.closeP()`\nClose a connection. Instead of firing a `close` event, this function returns a promise that gets fulfilled once the connection has closed.\n\n## Events\n\n### `mySocket.on('ready', function () {})`\nFired when the socket is ready to use.\n\n### `mySocket.on('message', function (message) {})`\nReceived a message from the AppRtc server. `message` is always a `String`.\n\n### `mySocket.on('close', function () {})`   \nFired when the connection has closed.   \n\n### `mySocket.on('error', function () {})`\nFired when a fatal error occurs.     \n\n## Examples\nSee examples directory.\n"
}