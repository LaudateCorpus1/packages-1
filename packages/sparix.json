{
  "name": "sparix",
  "version": "0.0.7-alpha.15",
  "description": "Single Page Application state management powered by RxJS",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "start": "npm run watch:test",
    "test": "karma start",
    "watch:test": "npm run test -- --auto-watch --no-single-run",
    "postinstall": "typings install",
    "prepublish": "npm test && npm run build",
    "prebuild": "shx rm -rf ./lib",
    "build": "tsc --project tsconfig.build.json"
  },
  "repository": {
    "user": "micouz",
    "repo": "sparix",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/micouz/sparix/tarball/master",
    "clone_url": "https://github.com/micouz/sparix",
    "https_url": "https://github.com/micouz/sparix",
    "travis_url": "https://travis-ci.org/micouz/sparix",
    "zip_url": "https://github.com/micouz/sparix/archive/master.zip",
    "api_url": "https://api.github.com/repos/micouz/sparix"
  },
  "author": {
    "name": "Mikael Couzic",
    "email": "mikaelcouzic@gmail.com",
    "url": "https://github.com/micouz"
  },
  "license": "MIT",
  "dependencies": {
    "immupdate": "^0.4.0"
  },
  "peerDependencies": {
    "rxjs": "^5.0.0-beta.6"
  },
  "devDependencies": {
    "awesome-typescript-loader": "^0.17.0",
    "core-js": "^2.4.0",
    "istanbul-instrumenter-loader": "^0.2.0",
    "jasmine-core": "^2.4.1",
    "karma": "^0.13.22",
    "karma-coverage": "^1.0.0",
    "karma-jasmine": "^1.0.2",
    "karma-mocha-reporter": "^2.0.3",
    "karma-phantomjs-launcher": "^1.0.0",
    "karma-sourcemap-loader": "^0.3.7",
    "karma-webpack": "^1.7.0",
    "phantomjs-prebuilt": "^2.1.7",
    "rxjs": "^5.0.0-beta.8",
    "shx": "^0.1.2",
    "source-map-loader": "^0.1.5",
    "ts-helpers": "^1.1.1",
    "ts-loader": "^0.8.2",
    "ts-node": "^0.7.2",
    "tslint": "^3.10.1",
    "tslint-loader": "^2.1.4",
    "typescript": "^1.8.10",
    "typings": "^1.0.4",
    "webpack": "^1.13.0",
    "webpack-merge": "^0.12.0"
  },
  "gitHead": "f38989f3372231a789577f396cfc3053f82ebd33",
  "homepage": "https://github.com/micouz/sparix#readme",
  "_npmVersion": "3.10.3",
  "_nodeVersion": "6.5.0",
  "dist": {
    "shasum": "da8fe44b6483eba8356e8103cfce5c7529062398",
    "tarball": "http://registry.npmjs.org/sparix/-/sparix-0.0.7-alpha.15.tgz"
  },
  "versions": [
    {
      "number": "0.0.1",
      "date": "2016-05-11T15:20:18.449Z"
    },
    {
      "number": "0.0.2",
      "date": "2016-05-11T15:23:02.531Z"
    },
    {
      "number": "0.0.3",
      "date": "2016-05-12T20:29:18.049Z"
    },
    {
      "number": "0.0.4",
      "date": "2016-05-18T11:43:56.474Z"
    },
    {
      "number": "0.0.5",
      "date": "2016-05-19T11:52:06.336Z"
    },
    {
      "number": "0.0.6",
      "date": "2016-05-24T21:44:13.451Z"
    },
    {
      "number": "0.0.7-alpha.0",
      "date": "2016-05-27T13:31:05.435Z"
    },
    {
      "number": "0.0.7-alpha.1",
      "date": "2016-05-27T14:36:15.192Z"
    },
    {
      "number": "0.0.7-alpha.2",
      "date": "2016-05-31T15:43:36.732Z"
    },
    {
      "number": "0.0.7-alpha.3",
      "date": "2016-06-01T12:33:22.406Z"
    },
    {
      "number": "0.0.7-alpha.4",
      "date": "2016-06-01T13:21:49.502Z"
    },
    {
      "number": "0.0.7-alpha.5",
      "date": "2016-06-03T09:36:44.932Z"
    },
    {
      "number": "0.0.7-alpha.6",
      "date": "2016-06-03T09:46:30.682Z"
    },
    {
      "number": "0.0.7-alpha.7",
      "date": "2016-06-03T10:04:25.088Z"
    },
    {
      "number": "0.0.7-alpha.8",
      "date": "2016-06-03T11:41:52.855Z"
    },
    {
      "number": "0.0.7-alpha.9",
      "date": "2016-06-03T11:54:19.562Z"
    },
    {
      "number": "0.0.7-alpha.10",
      "date": "2016-06-06T12:51:40.195Z"
    },
    {
      "number": "0.0.7-alpha.11",
      "date": "2016-07-01T11:08:14.833Z"
    },
    {
      "number": "0.0.7-alpha.12",
      "date": "2016-07-04T10:05:18.287Z"
    },
    {
      "number": "0.0.7-alpha.13",
      "date": "2016-09-20T12:29:17.081Z"
    },
    {
      "number": "0.0.7-alpha.14",
      "date": "2016-09-22T11:41:44.955Z"
    },
    {
      "number": "0.0.7-alpha.15",
      "date": "2016-09-22T11:59:45.168Z"
    }
  ],
  "created": "2016-05-11T15:20:18.449Z",
  "modified": "2016-09-22T11:59:45.168Z",
  "lastPublisher": {
    "name": "adapteach",
    "email": "adapteach@yahoo.fr"
  },
  "owners": [
    {
      "name": "adapteach",
      "email": "adapteach@yahoo.fr"
    }
  ],
  "readme": "# sparix\n\n## DISCLAIMER: Serious WIP !!!\n\n#### Single Page Application state management powered by RxJS\n###### Inspired by Flux, Redux, Hexagonal Architecture and more..\n\n### Introduction\nThis project aims to alleviate the pain in SPA development by providing a set of opiniated tools and patterns to model the application core's state, in a simple, easily testable and immutable way. In the sparix world, the state is encapsulated in Stores, which are responsible for updating the state. This state is made publically available as an Observable, or in other words as a succession of state transitions. Several stores can communicate between themselves by dispatching global events.\n\n### Quickstart\n\n#### Install\n```sh\n$ npm i -S sparix rxjs\n```\n\n#### Create a Store\n```ts\nimport {Store, EventQueue} from 'sparix'\n\nexport interface CounterState {\n    count: number\n}\n\nconst initialState: CounterState = {\n    count: 0\n}\n\nexport class Counter extends Store<CounterState> {\n    constructor(eventQueue: EventQueue) {\n        super(eventQueue, initialState)\n    }\n    \n    increment() {\n        this.updateState({count: val => val + 1})\n    }\n}\n```\n\n#### Consume the Store's state\n```ts\nimport {Counter} from './counter'\n\nconst counter: Counter = ... // Get counter instance from exported module or dependency injection\n\n// Recommended way\nconst count$: Observable<number> = counter.map(state => state.count)\n\n// Alternative way (useful for testing)\nexpect(counter.currentState.count).toEqual(0)\ncounter.increment()\nexpect(counter.currentState.count).toEqual(1)\n```\n\n#### Dispatch an Event\n```ts\nexport class CountIncremented {\n    constructor(public newCount: number) {}\n}\n\nexport class Counter extends Store<CounterState> {\n    // constructor\n    \n    increment() {\n        this.updateState({count: val => val + 1})\n        this.dispatch(state => new CountIncremented(state.count))\n    }\n}\n```\n\n#### Handle an Event\n```ts\nimport {Store, EventQueue} from 'sparix'\nimport {CountIncremented} from './counter'\n\nexport interface EvenCountState {\n    isEven: boolean\n}\n\nconst initialState: EvenCountState = {\n    isEven: true\n}\n\nexport class EventCountStore extends Store<EvenCountState> {\n    constructor(eventQueue: EventQueue) {\n        super(eventQueue, initialState)\n        this.on(CountIncremented, event => this.updateState({isEven: event.newCount % 2 === 0}) \n    }\n}\n```\n\n### What is sparix ?\nFirst, it's a pattern (or set of patterns). Second, it's an implementation based on RxJS. The implementation is quite trivial, and it would only take a few hours to migrate it to another reactive library. However, since the SPA world will soon be dominated by two giants, React and Angular2, and since the latter ships with RxJS, it made sense to use this library for the reference implementation of sparix.\n\n### How it compares to redux\nIn redux, when you need to update the state, you dispatch an action. But if you look closely, you might realize that actions can be sorted in two categories :\n* Actions that target a single reducer, to update a single subset of the state tree. Their names are usually in imperative form (*ADD_TODO*, *INCREMENT_COUNTER*...). I call them **Updaters**.\n* Actions that target one or many reducers, to notify the system that something happened. Their names are usually in declarative form (*TODO_SAVED*, *TODO_SAVE_FAILED*...). I call them **Events**.\n \nMy claim is that actions are too heavy a mechanism when the goal is simply to update a single Store's state (as in most cases). In sparix, a Store can directly update its state with no more ceremony than:\n```ts\n// Increment counter\nthis.update(state => ({\n    counter: state.counter + 1\n}))\n```\nThere is a finer-grained, more declarative way to write these state updaters:\n```ts\nthis.updateState({\n    counter: prevCounter => prevCounter + 1\n})\n```\nOr even better:\n```ts\nconst increment = value => value + 1\n\nthis.updateState({\n    counter: increment\n})\n```\nWell, actually you should leverage Ramda's automatic currying:\n```ts\nimport {add} from 'ramda'\n\nthis.updateState({\n    counter: add(1)\n})\n```\nI like to think of these state updaters as anonymous actions. In redux, it would be like dispatching a reducer. But what about action creators ? Well, we don't need them really: \n```ts\nconst increment = R.add(1)\n\nclass SomeStore extends Store<SomeState> {\n    // constructor\n    incrementCounter() {\n        this.updateState({\n            counter: increment\n        })\n    }\n}\n```\nHere, the `incrementCounter()` method is part of the Store's public API. You no longer need to dispatch a global action created by an action creator. Just call the method !\n\n## Philosophy\n\n### Core\nSparix is all about modeling your application's core. But what is a core ? Or rather, what's NOT in the core ?\n\nThe application core should be agnostic. Agnostic to frameworks and databases, agnostic to the presentation layer, agnostic to the data fetching mechanism and protocols. It should be agnostic To **EVERYTHING**.\n\nThe application core doesn't know about HTML, the DOM, Angular or React, Local Storage, HTTP or WebSockets.. It doesn't even know that it lives in a web browser ! The same application core should be reusable in Cordova, NativeScript or Electron apps **without changing a single line of code** ! \n\nSo what do you put in the core ? The answer is quite simple: **everything else** ! If it can be part of the core, it should be part of the core. All the business logic, the data transformations, the interaction logic, should be modeled as the application core. And **none of that** should depend on anything else than the programming language which was used to model it.\n\nSo back to sparix. It will help you model an application core that does not depend on third-party libraries and frameworks, with two exceptions being RxJS and sparix itself. But that's not much of a problem. Observables are on their way of becoming a standard ECMAScript feature, and sparix is a non-intrusive library, which makes it easy to model only a subset of your application core with it.\n\n### Immutablility\nIn sparix, the state is modeled as an `Observable<State>`, an immutable stream of immutable states. There can be no side effects. It's as simple as that.\n\n### Testability\nSparix introduces the concept of Diamond Architecture. Stores have two kinds of inputs:\n* Public methods\n* Events\n\nAnd two kinds of outputs:\n* The stream of states\n* Events\n\nA Store's API is kept simple, and all the complex logic is encapsulated and hidden from the outside, just like you would do with good old Object Oriented  Programming. To test a Store, all you need to do is simulate an input (either by calling its public methods or dispatching an event), and check the output (state or events).\n\n## Concepts\n\n### Store\n\nEach Store represents a cohesive functional subset of your application's core.\n\nBehavior = Core\n\nStateful core = Store\n\n### Event\nEvent though most of the time you just want to update the state of a single Store, sometimes you want to dispatch an app-wide event that **any** store could decide it is interested in. Or sometimes you know that only a single store will ever listen to a specific event, but you might still decide to use events just to decouple Stores from each other (and I suggest you do !).\n\nAn event is dispatched to all registered Stores before the next event in the queue gets dispatched.\n"
}