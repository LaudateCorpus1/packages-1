{
  "name": "linvodb3",
  "version": "3.23.1",
  "author": {
    "name": "Ivo Georgiev",
    "email": "ivo@linvo.com"
  },
  "contributors": [
    {
      "name": "Louis Chatriot"
    },
    {
      "name": "Ivo Georgiev"
    }
  ],
  "description": "Model-oriented embedded database, inspired by Mongoose & MongoDB, over LevelUP",
  "keywords": [
    "database",
    "datastore",
    "embedded",
    "levelup",
    "mongoose"
  ],
  "homepage": "https://github.com/Ivshti/linvodb3",
  "repository": {
    "user": "Ivshti",
    "repo": "linvodb3",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/Ivshti/linvodb3/tarball/master",
    "clone_url": "https://github.com/Ivshti/linvodb3",
    "https_url": "https://github.com/Ivshti/linvodb3",
    "travis_url": "https://travis-ci.org/Ivshti/linvodb3",
    "zip_url": "https://github.com/Ivshti/linvodb3/archive/master.zip",
    "api_url": "https://api.github.com/repos/Ivshti/linvodb3"
  },
  "dependencies": {
    "async": "1.x.x",
    "bagpipe": "github:ivshti/bagpipe",
    "binary-search-tree": "0.2.6",
    "hat": "0.0.3",
    "levelup": "^1.2.1",
    "underscore": "1.8.x",
    "path": "^0.12.7",
    "util": "github:ivshti/node-util"
  },
  "devDependencies": {
    "chai": "1.0.x",
    "commander": "1.1.1",
    "exec-time": "0.0.2",
    "leveldown": "^1.3.0",
    "mocha": "1.4.x",
    "request": "2.9.x",
    "rimraf": "2.2.x",
    "sinon": "1.3.x",
    "memdown": "^1.1.2",
    "browserify": "13.x.x",
    "level-js": "^2.2.3"
  },
  "scripts": {
    "test": "mocha --reporter spec --timeout 10000"
  },
  "main": "index",
  "licence": "MIT",
  "gitHead": "cd00679a80de4819a2e85ce10d5d75491add0d00",
  "_npmVersion": "2.15.8",
  "_nodeVersion": "4.4.7",
  "dist": {
    "shasum": "f816f5fa2963e3c79edb17bc5eddba181d54a356",
    "tarball": "http://registry.npmjs.org/linvodb3/-/linvodb3-3.23.1.tgz"
  },
  "stars": 0,
  "versions": [
    {
      "number": "3.5.0",
      "date": "2015-01-28T19:16:17.860Z"
    },
    {
      "number": "3.7.0",
      "date": "2015-03-08T07:35:52.076Z"
    },
    {
      "number": "3.7.2",
      "date": "2015-04-13T13:53:08.372Z"
    },
    {
      "number": "3.7.3",
      "date": "2015-04-13T16:09:59.303Z"
    },
    {
      "number": "3.7.6",
      "date": "2015-05-11T11:35:20.812Z"
    },
    {
      "number": "3.8.0",
      "date": "2015-05-31T06:41:40.252Z"
    },
    {
      "number": "3.8.1",
      "date": "2015-05-31T06:52:56.825Z"
    },
    {
      "number": "3.8.2",
      "date": "2015-05-31T07:05:54.358Z"
    },
    {
      "number": "3.9.0",
      "date": "2015-07-01T10:42:28.824Z"
    },
    {
      "number": "3.9.1",
      "date": "2015-07-14T17:16:58.064Z"
    },
    {
      "number": "3.9.2",
      "date": "2015-07-15T13:09:30.899Z"
    },
    {
      "number": "3.9.3",
      "date": "2015-07-19T19:16:50.663Z"
    },
    {
      "number": "3.10.0",
      "date": "2015-07-27T12:46:38.001Z"
    },
    {
      "number": "3.10.2",
      "date": "2015-08-06T23:48:56.313Z"
    },
    {
      "number": "3.10.3",
      "date": "2015-09-04T13:30:38.672Z"
    },
    {
      "number": "3.10.5",
      "date": "2015-10-07T09:41:52.882Z"
    },
    {
      "number": "3.11.0",
      "date": "2015-10-07T13:13:06.179Z"
    },
    {
      "number": "3.11.1",
      "date": "2015-10-11T19:30:16.125Z"
    },
    {
      "number": "3.11.2",
      "date": "2015-11-17T12:28:22.600Z"
    },
    {
      "number": "3.12.0",
      "date": "2015-12-22T14:16:49.858Z"
    },
    {
      "number": "3.13.0",
      "date": "2016-01-05T21:59:35.919Z"
    },
    {
      "number": "3.14.1",
      "date": "2016-03-03T23:27:59.550Z"
    },
    {
      "number": "3.14.2",
      "date": "2016-03-06T11:22:29.175Z"
    },
    {
      "number": "3.15.0",
      "date": "2016-03-16T10:17:30.680Z"
    },
    {
      "number": "3.16.0",
      "date": "2016-03-16T12:28:40.725Z"
    },
    {
      "number": "3.16.1",
      "date": "2016-03-16T12:39:56.189Z"
    },
    {
      "number": "3.16.2",
      "date": "2016-03-16T13:05:17.702Z"
    },
    {
      "number": "3.16.3",
      "date": "2016-03-16T13:16:35.568Z"
    },
    {
      "number": "3.16.4",
      "date": "2016-03-16T13:36:30.245Z"
    },
    {
      "number": "3.16.5",
      "date": "2016-03-16T13:38:34.320Z"
    },
    {
      "number": "3.16.6",
      "date": "2016-03-16T13:39:25.224Z"
    },
    {
      "number": "3.16.7",
      "date": "2016-03-16T13:54:39.568Z"
    },
    {
      "number": "3.16.8",
      "date": "2016-04-08T13:03:56.630Z"
    },
    {
      "number": "3.16.9",
      "date": "2016-04-08T13:53:43.327Z"
    },
    {
      "number": "3.16.10",
      "date": "2016-04-08T14:07:07.320Z"
    },
    {
      "number": "3.17.0",
      "date": "2016-05-04T15:53:57.343Z"
    },
    {
      "number": "3.18.0",
      "date": "2016-05-15T00:23:46.856Z"
    },
    {
      "number": "3.19.0",
      "date": "2016-06-03T22:51:02.531Z"
    },
    {
      "number": "3.21.0",
      "date": "2016-06-21T13:50:07.628Z"
    },
    {
      "number": "3.22.0",
      "date": "2016-06-21T13:56:21.092Z"
    },
    {
      "number": "3.22.1",
      "date": "2016-06-21T13:59:40.422Z"
    },
    {
      "number": "3.22.2",
      "date": "2016-06-21T14:07:44.632Z"
    },
    {
      "number": "3.22.3",
      "date": "2016-06-25T19:12:01.265Z"
    },
    {
      "number": "3.23.0",
      "date": "2016-07-11T23:04:12.237Z"
    },
    {
      "number": "3.23.1",
      "date": "2016-07-11T23:12:02.931Z"
    }
  ],
  "created": "2015-01-28T19:16:17.860Z",
  "modified": "2016-07-11T23:12:02.931Z",
  "lastPublisher": {
    "name": "ivogeorgiev",
    "email": "ivo@linvo.com"
  },
  "owners": [
    {
      "name": "ivogeorgiev",
      "email": "ivo@linvo.com"
    }
  ],
  "readme": "LinvoDB\n=========\n\nLinvoDB is a Node.js/NW.js/Electron persistent DB with MongoDB / Mongoose-like features and interface.\n\n### Features:\n\n* **MongoDB-like query language**\n* **Persistence** built on LevelUP - you can **pick back-end**\n* **NW.js/Electron friendly** - JS-only backend is [level-js](https://www.npmjs.com/package/level-js) or [Medea](https://github.com/medea/medea)\n* **Performant** - steady performance unaffected by DB size - queries are always indexed\n* **Auto-indexing**\n* **Live queries** - make the query, get constantly up-to-date results\n* **Schemas** - built-in schema support\n* **Efficient Map / Reduce / Limit**\n\n### Coming soon:\n\n* **Streaming cursors**\n* **Distributed dataset**\n\n\nRelationship to NeDB\n--------------------\nLinvoDB is based on NeDB, the most significant core change is that it uses LevelUP as a back-end, meaning it doesn't have to keep the whole dataset in memory. LinvoDB also can do a query entirely by indexes, meaning it doesn't have to scan the full database on a query. \n\nIn general:\n\n* LinvoDB is better for large datasets (many objects, or large objects) because it doesn't keep the whole DB in memory and doesn't need to always scan it\n* LinvoDB does the entire query through the indexes, NeDB scans the DB\n* Both LinvoDB and NeDB play well with NW.js (node-webkit). LinvoDB can be initialized with the JS-only level-js back-end.\n* NeDB is ultra-fast because the DB is in memory, LinvoDB's performance is comparible to MongoDB. LinvoDB is faster for large datasets.\n* LinvoDB has live queries, map/reduce and schema support.\n* Both LinvoDB and NeDB are unsuitable for huge datasets (big data)\n* Combining NeDB's in-memory data and LinvoDB's full-indexed queries would yield even better performance. If you want to sacrifice memory for query performance, you can use LinvoDB with a backend that works like that or with LevelDB + increased LRU cache\n\n\nInstall, Initialize, pick backend\n-------------------------\n\nInstall:\n```javascript\nnpm install linvodb3 level-js # For NW.js, using level-js\nnpm install linvodb3 leveldown # For pure node.js, using LevelDB\n```\n\nInitialize:\n```javascript\nvar LinvoDB = require(\"linvodb3\");\n\n// The following two lines are very important\n// Initialize the default store to level-js - which is a JS-only store which will work without recompiling in NW.js / Electron\nLinvoDB.defaults.store = { db: require(\"level-js\") }; // Comment out to use LevelDB instead of level-js\n// Set dbPath - this should be done explicitly and will be the dir where each model's store is saved\nLinvoDB.dbPath = process.cwd(); \n\nvar Doc = new LinvoDB(\"doc\", { /* schema, can be empty */ })\n```\n\nInitialization, detailed:\n```javascript\nvar LinvoDB = require(\"linvodb3\");\nvar modelName = \"doc\";\nvar schema = { }; // Non-strict always, can be left empty\nvar options = { };\n// options.filename = \"./test.db\"; // Path to database - not necessary \n// options.store = { db: require(\"level-js\") }; // Options passed to LevelUP constructor \nvar Doc = new LinvoDB(modelName, schema, options); // New model; Doc is the constructor\n\nLinvoDB.dbPath // default path where data files are stored for each model\nLinvoDB.defaults // default options for every model\n```\n\nInsert / Save\n-------------\nThe native types are `String`, `Number`, `Boolean`, `Date` and `null`. You can also use\narrays and subdocuments (objects). If a field is `undefined`, it will not be saved.  \n\nIf the document does not contain an `_id` field, one will be automatically generated (a 16-characters alphanumerical string). The `_id` of a document, once set, cannot be modified.\n\n```javascript\n// Construct a single document and then save it\nvar doc = new Doc({ a: 5, now: new Date(), test: \"this is a string\" });\ndoc.b = 13; // you can modify the doc \ndoc.save(function(err) { \n\t// Document is saved\n\tconsole.log(doc._id);\n});\n\n// Insert document(s)\n// you can use the .insert method to insert one or more documents\nDoc.insert({ a: 3 }, function (err, newDoc) {\n\tconsole.log(newDoc._id);\n});\nDoc.insert([{ a: 3 }, { a: 42 }], function (err, newDocs) {\n\t// Two documents were inserted in the database\n\t// newDocs is an array with these documents, augmented with their _id\n\n\t// If there's an unique constraint on 'a', this will fail, and no changes will be made to the DB\n\t// err is a 'uniqueViolated' error\n});\n\n// Save document(s)\n// save is like an insert, except it allows saving existing document too\nDoc.save([ doc, { a: 55, test: \".save is handy\" } ], function(err, docs) { \n\t// docs[0] is doc\n\t// docs[1] is newly-inserted document with a=55 and has an assigned _id\n\n\t// Doing that with .insert would throw an uniqueViolated error for _id on doc, because it assumes all documents are new\n});\n```\n\nQuerying\n------------------------\nUse `find` to look for multiple documents matching you query, or `findOne` to look for one specific document. You can select documents based on field equality or use comparison operators (`$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$nin`, `$ne`, `$regex`, `$exists`). You can also use logical operators `$or`, `$and` and `$not`. See below for the syntax.\n\n```javascript\nvar Planet = new LinvoDB(\"planet\", { /* schema, can be empty */ })\n\n// Let's say our datastore contains the following collection\nPlanet.save([ \n\t{ _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] },\n\t{ _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: { genders: 2, eyes: true } },\n\t{ _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false },\n\t{ _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: { genders: 7 } },\n\t{ _id: 'id5', completeData: { planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] } }\n], function() { \n\n// Finding all planets in the solar system\nPlanet.find({ system: 'solar' }, function (err, docs) {\n  // docs is an array containing documents Mars, Earth, Jupiter\n  // If no document is found, docs is equal to []\n});\n\n// Finding all inhabited planets in the solar system\nPlanet.find({ system: 'solar', inhabited: true }, function (err, docs) {\n  // docs is an array containing document Earth only\n});\n\n// Use the dot-notation to match fields in subdocuments\nPlanet.find({ \"humans.genders\": 2 }, function (err, docs) {\n  // docs contains Earth\n});\n\n// Use the dot-notation to navigate arrays of subdocuments\nPlanet.find({ \"completeData.planets.name\": \"Mars\" }, function (err, docs) {\n  // docs contains document 5\n});\n\nPlanet.find({ \"completeData.planets.0.name\": \"Earth\" }, function (err, docs) {\n  // docs contains document 5\n  // If we had tested against \"Mars\" docs would be empty because we are matching against a specific array element\n});\n\n// You can also deep-compare objects. Don't confuse this with dot-notation!\nPlanet.find({ humans: { genders: 2 } }, function (err, docs) {\n  // docs is empty, because { genders: 2 } is not equal to { genders: 2, eyes: true }\n});\n\n// Find all documents in the collection\nPlanet.find({}, function (err, docs) {\n});\n\n// The same rules apply when you want to only find one document\nPlanet.findOne({ _id: 'id1' }, function (err, doc) {\n  // doc is the document Mars\n  // If no document is found, doc is null\n});\n\n\n}); // end of .save()\n```\n#### Operators ($lt, $lte, $gt, $gte, $in, $nin, $ne, $exists, $regex)\nThe syntax is `{ field: { $op: value } }` where `$op` is any comparison operator:  \n\n* `$lt`, `$lte`: less than, less than or equal\n* `$gt`, `$gte`: greater than, greater than or equal\n* `$in`: member of. `value` must be an array of values\n* `$ne`, `$nin`: not equal, not a member of\n* `$exists`: checks whether the document posses the property `field`. `value` should be true or false\n* `$regex`: checks whether a string is matched by the regular expression. Contrary to MongoDB, the use of `$options` with `$regex` is not supported, because it doesn't give you more power than regex flags. Basic queries are more readable so only use the `$regex` operator when you need to use another operator with it (see example below)\n\n```javascript\n// $lt, $lte, $gt and $gte work on numbers and strings\nPlanet.find({ \"humans.genders\": { $gt: 5 } }, function (err, docs) {\n  // docs contains Omicron Persei 8, whose humans have more than 5 genders (7).\n});\n\n// When used with strings, lexicographical order is used\nPlanet.find({ planet: { $gt: 'Mercury' }}, function (err, docs) {\n  // docs contains Omicron Persei 8\n})\n\n// Using $in. $nin is used in the same way\nPlanet.find({ planet: { $in: ['Earth', 'Jupiter'] }}, function (err, docs) {\n  // docs contains Earth and Jupiter\n});\n\n// Using $exists\nPlanet.find({ satellites: { $exists: true } }, function (err, docs) {\n  // docs contains only Mars\n});\n\n// Using $regex with another operator\nPlanet.find({ planet: { $regex: /ar/, $nin: ['Jupiter', 'Earth'] } }, function (err, docs) {\n  // docs only contains Mars because Earth was excluded from the match by $nin\n});\n```\n\n#### Array fields\nWhen a field in a document is an array the query is treated as a query on every element and there is a match if at least one element matches.\n\n```javascript\n// If a document's field is an array, matching it means matching any element of the array\nPlanet.find({ satellites: 'Phobos' }, function (err, docs) {\n  // docs contains Mars. Result would have been the same if query had been { satellites: 'Deimos' }\n});\n\n// This also works for queries that use comparison operators\nPlanet.find({ satellites: { $lt: 'Amos' } }, function (err, docs) {\n  // docs is empty since Phobos and Deimos are after Amos in lexicographical order\n});\n\n// This also works with the $in and $nin operator\nPlanet.find({ satellites: { $in: ['Moon', 'Deimos'] } }, function (err, docs) {\n  // docs contains Mars (the Earth document is not complete!)\n});\n```\n\n#### Logical operators $or, $and, $not\nYou can combine queries using logical operators:  \n\n* For `$or` and `$and`, the syntax is `{ $op: [query1, query2, ...] }`.\n* For `$not`, the syntax is `{ $not: query }`\n\n```javascript\nPlanet.find({ $or: [{ planet: 'Earth' }, { planet: 'Mars' }] }, function (err, docs) {\n  // docs contains Earth and Mars\n});\n\nPlanet.find({ $not: { planet: 'Earth' } }, function (err, docs) {\n  // docs contains Mars, Jupiter, Omicron Persei 8\n});\n\n// You can mix normal queries, comparison queries and logical operators\nPlanet.find({ $or: [{ planet: 'Earth' }, { planet: 'Mars' }], inhabited: true }, function (err, docs) {\n  // docs contains Earth\n});\n```\n\n#### Sorting and paginating\nIf you don't specify a callback to `find`, `findOne` or `count`, a `Cursor` object is returned. You can modify the cursor with `sort`, `skip` and `limit` and then execute it with `exec(callback)`.\n\n```javascript\nvar Planet = new LinvoDB(\"planet\", { /* schema, can be empty */ })\n\nvar doc1,doc2,doc3,doc4;\n\nPlanet.save([\n\tdoc1 = { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] },\n\tdoc2 = { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: { genders: 2, eyes: true } },\n\tdoc3 = { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false },\n\tdoc4 = { _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: { genders: 7 } }\n], function() { \n\n// No query used means all results are returned (before the Cursor modifiers)\nPlanet.find({}).sort({ planet: 1 }).skip(1).limit(2).exec(function (err, docs) {\n  // docs is [doc3, doc1]\n});\n\n// You can sort in reverse order like this\nPlanet.find({ system: 'solar' }).sort({ planet: -1 }).exec(function (err, docs) {\n  // docs is [doc1, doc3, doc2]\n});\n\n// You can sort on one field, then another, and so on like this:\nPlanet.find({}).sort({ firstField: 1, secondField: -1 }) ...   // You understand how this works!\n\n}); // end of .save\n```\n\n### Counting documents\nYou can use `count` to count documents. It has the same syntax as `find`. For example:\n\n```javascript\n// Count all planets in the solar system\nPlanet.count({ system: 'solar' }, function (err, count) {\n  // count equals to 3\n});\n\n// Count all documents via cursor\nPlanet.find({}).count(function (err, count) {\n  // count equals to 4\n});\n```\n\n\nMap / Reduce / Filter / Aggregate\n------------\nBesides the standard pagination and sorting Cursor methods, we have the `filter`, `map` and `reduce` modifiers.\t\nBefore seeing the examples, you should know that **you can combine any of these modifiers in any order/way and all will be executed**. For example, you can run a regular query with .find and then run a reduce on it. \nNo matter how you combine those modifiers, the order of execution is: *query, filter, sort, limit/skip, map, reduce, aggregate*.\n\nThe basic syntax is:\n\n`Cursor.map(function(val){ return val })`\n\n`Cursor.reduce(function reducer(a,b), initial);`\n\n`Cursor.filter(function(val) { return true /* or false*/ }); // truthy / falsy values accepted`\n\n`Cursor.aggregate(function(res) { /* do something to the result of the query right before serving */ return res })`\n\n```javascript\n// Let's assume this dataset\nvar Planet = new LinvoDB(\"planet\", { /* schema, can be empty */ })\nPlanet.save([\n\tdoc1 = { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] },\n\tdoc2 = { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: { genders: 2, eyes: true } },\n\tdoc3 = { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false },\n\tdoc4 = { _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: { genders: 7 } }\n], function() { \n\n// Map/reduce capabilities\nPlanet.find({ system: 'solar' }).sort({ planet: 1 })\n.map(function(x) { return x.planet })\n.reduce(function(a, b) { return a+\", \"+b }, \"\")\n.exec(function(err, res) { \n\t// res is \"Earth, Jupiter, Mars\"\n});\n\n// The largest number of human genders\nPlanet.find({ \"humans.genders\": { $exists: true } })\n.map(function(x) { return x.humans.genders })\n.reduce(function(a,b) { return Math.max(a,b) }, 0)\n.exec(function(err,res) { \n\t// res is 7\n});\n\n// Combine map and filter only\n// As you can see, you can use map if you want to project only a part of the data\nPlanet.find({})\n.filter(function(x){ return x.planet.length > 5 })\n.map(function(x){ return { planet: x.planet } })\n.exec(function(err,res) { \n\t// res is [{ planet: 'Jupiter' }, { planet: 'Omicron Persei 8' }]\n});\n\n// Use aggregate to emulate count\nPlanet.find({}).aggregate(function(res){ return res.length }).exec(function(err,res) { \n\t// res is 4\n});\n\n// Combine all the methods, because we can\nPlanet.find({ system: \"solar\" }) // we have Mars, Earth, Jupiter remaining\n.sort({ inhabited: 1 })\n.limit(2) // Earth falls out, we have Mars, Jupiter\n.filter(function(x){ return x.planet.length > 5 }) // only Jupiter remains\n.map(function(x) { return x.planet })\n.reduce(function(a,b) { return a+\" \"+b }, \"planets are:\")\n.aggregate(function(res) { return res+\", those are uninhabited and in the solar system, with a long name\" })\n.exec(function(err,res){ console.log(res) }); // \"planets are: Jupiter, those are uninhabited and in the solar system, with a long name\"\n\n}); // end .save()\n```\n\nLive Queries\n-----------------\nOnce you have a `Cursor` object, returned by calling `find` without a callback, you can turn it into a live query, meaning the `.res` property will always be up-to-date results from the query. Of course, all modifiers, such as `limit`, `skip`, `sort`, `map`, `reduce`, `filter` and `aggregate` will still apply.\n\nAn event will be emitted when the result is updated - `liveQueryUpdate` on the model itself.\n\n**Seriously consider if live queries can be utilized in your application** - if you need particular results continuously, using live queries is extremely efficient, since you don't have to re-read the database but results are kept up-to-date as you update the documents. \n\n```javascript\n// Let's assume this dataset\nvar Planet = new LinvoDB(\"planet\", { /* schema, can be empty */ })\nPlanet.save([\n\t{ _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] },\n\t{ _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: { genders: 2, eyes: true } },\n\t{ _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false },\n\t{ _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: { genders: 7 } }\n], function(err, docs) { \n\nvar live = Planet.find({ system: \"solar\" }).sort({ inhabited: -1 }).limit(2).live(); // don't forget you can still use map, reduce, filter, aggregate\n\nPlanet.on(\"liveQueryUpdate\", function() { \n\t// we'll log this twice, once on the initial result and then again once we update document\n\t// we won't get this emitted if we modify the dataset with documents that do not fit the query ({ system: solar })\n\tconsole.log(live.res);\n});\n\nsetTimeout(function() {\n\tdocs[1].inhabited = false; // Earth catastrophe \n\tdocs[1].save(); // Save Earth\n}, 666);\n\n}); // end .save()\n```\n\n### Angular Disclaimer\nIf you plan to use **Live Queries with AngularJS** and update scope on the `liveQueryUpdated` event please be careful. First, I recommend using `$digest` when possible instead of `$apply` (dirty-check only the current scope). Second, I recommend debouncing the event before running the `$scope.$apply()` event to avoid $apply being called many times because of heavy DB use at a moment.\n\n\nUpdating\n--------------\n\n### Re-saving a document\n`doc.save()` - you can use `save` on a document instance to re-save it, therefore updating it.\n```javascript\n// Let's use the same example collection as in the \"finding document\" part\n// { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false }\n// { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true }\n// { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\n// { _id: 'id4', planet: 'Omicron Persia 8', system: 'futurama', inhabited: true }\n\nPlanet.findOne({ planet: 'Earth' }, function(err, doc) {\n\tdoc.inhabited = false;\n\tdoc.save(function(err) { /* we have updated the Earth doc */ }); \n});\n```\n\n### Atomic updating\n`Doc.update(query, update, options, callback)` will update all documents matching `query` according to the `update` rules:  \n* `query` is the same kind of finding query you use with `find` and `findOne`\n* `update` specifies how the documents should be modified. It is either a new document or a set of modifiers (you cannot use both together, it doesn't make sense!)\n  * A new document will replace the matched docs\n  * The modifiers create the fields they need to modify if they don't exist, and you can apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field and `$inc` to increment a field's value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special `$each`. See examples below for the syntax.\n* `options` is an object with two possible parameters\n  * `multi` (defaults to `false`) which allows the modification of several documents if set to true\n  * `upsert` (defaults to `false`) if you want to insert a new document corresponding to the `update` rules if your `query` doesn't match anything. If your `update` is a simple object with no modifiers, it is the inserted document. In the other case, the `query` is stripped from all operator recursively, and the `update` is applied to it.\n* `callback` (optional) signature: `err`, `numReplaced`, `newDoc`\n  * `numReplaced` is the number of documents replaced\n  * `newDoc` is the created document if the upsert mode was chosen and a document was inserted\n\n**Note**: you can't change a document's _id.\n\n```javascript\n// Let's use the same example collection as in the \"finding document\" part\n// { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false }\n// { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true }\n// { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\n// { _id: 'id4', planet: 'Omicron Persia 8', system: 'futurama', inhabited: true }\n\n// Replace a document by another\nPlanet.update({ planet: 'Jupiter' }, { planet: 'Pluton'}, {}, function (err, numReplaced) {\n  // numReplaced = 1\n  // The doc #3 has been replaced by { _id: 'id3', planet: 'Pluton' }\n  // Note that the _id is kept unchanged, and the document has been replaced\n  // (the 'system' and inhabited fields are not here anymore)\n});\n\n// Set an existing field's value\nPlanet.update({ system: 'solar' }, { $set: { system: 'solar system' } }, { multi: true }, function (err, numReplaced) {\n  // numReplaced = 3\n  // Field 'system' on Mars, Earth, Jupiter now has value 'solar system'\n});\n\n// Setting the value of a non-existing field in a subdocument by using the dot-notation\nPlanet.update({ planet: 'Mars' }, { $set: { \"data.satellites\": 2, \"data.red\": true } }, {}, function () {\n  // Mars document now is { _id: 'id1', system: 'solar', inhabited: false\n  //                      , data: { satellites: 2, red: true }\n  //                      }\n  // Not that to set fields in subdocuments, you HAVE to use dot-notation\n  // Using object-notation will just replace the top-level field\n  Planet.update({ planet: 'Mars' }, { $set: { data: { satellites: 3 } } }, {}, function () {\n    // Mars document now is { _id: 'id1', system: 'solar', inhabited: false\n    //                      , data: { satellites: 3 }\n    //                      }\n    // You lost the \"data.red\" field which is probably not the intended behavior\n  });\n});\n\n// Deleting a field\nPlanet.update({ planet: 'Mars' }, { $unset: { planet: true } }, {}, function () {\n  // Now the document for Mars doesn't contain the planet field\n  // You can unset nested fields with the dot notation of course\n});\n\n// Upserting a document\nPlanet.update({ planet: 'Pluton' }, { planet: 'Pluton', inhabited: false }, { upsert: true }, function (err, numReplaced, upsert) {\n  // numReplaced = 1, upsert = { _id: 'id5', planet: 'Pluton', inhabited: false }\n  // A new document { _id: 'id5', planet: 'Pluton', inhabited: false } has been added to the collection\n});\n\n// If you upsert with a modifier, the upserted doc is the query modified by the modifier\n// This is simpler than it sounds :)\nPlanet.update({ planet: 'Pluton' }, { $inc: { distance: 38 } }, { upsert: true }, function () {\n  // A new document { _id: 'id5', planet: 'Pluton', distance: 38 } has been added to the collection  \n});\n\n// If we insert a new document { _id: 'id6', fruits: ['apple', 'orange', 'pear'] } in the collection,\n// let's see how we can modify the array field atomically\n\n// $push inserts new elements at the end of the array\nPlanet.update({ _id: 'id6' }, { $push: { fruits: 'banana' } }, {}, function () {\n  // Now the fruits array is ['apple', 'orange', 'pear', 'banana']\n});\n\n// $pop removes an element from the end (if used with 1) or the front (if used with -1) of the array\nPlanet.update({ _id: 'id6' }, { $pop: { fruits: 1 } }, {}, function () {\n  // Now the fruits array is ['apple', 'orange']\n  // With { $pop: { fruits: -1 } }, it would have been ['orange', 'pear']\n});\n\n// $addToSet adds an element to an array only if it isn't already in it\n// Equality is deep-checked (i.e. $addToSet will not insert an object in an array already containing the same object)\n// Note that it doesn't check whether the array contained duplicates before or not\nPlanet.update({ _id: 'id6' }, { $addToSet: { fruits: 'apple' } }, {}, function () {\n  // The fruits array didn't change\n  // If we had used a fruit not in the array, e.g. 'banana', it would have been added to the array\n});\n\n// $pull removes all values matching a value or even any query from the array\nPlanet.update({ _id: 'id6' }, { $pull: { fruits: 'apple' } }, {}, function () {\n  // Now the fruits array is ['orange', 'pear']\n});\nPlanet.update({ _id: 'id6' }, { $pull: { fruits: $in: ['apple', 'pear'] } }, {}, function () {\n  // Now the fruits array is ['orange']\n});\n\n\n\n// $each can be used to $push or $addToSet multiple values at once\n// This example works the same way with $addToSet\nPlanet.update({ _id: 'id6' }, { $push: { fruits: {$each: ['banana', 'orange'] } } }, {}, function () {\n  // Now the fruits array is ['apple', 'orange', 'pear', 'banana', 'orange']\n});\n```\n\nRemoving\n-------------\n\n### Removing a document instance\n```javascript\n// if you have the document instance at hand, you can just\nDoc.findOne({ planet: 'Mars' }, function(err, doc) {\n\tdoc.remove(function() {\n\t\t// done\n\t});\t\n});\n```\n\n### Removing from the collection\n`Doc.remove(query, options, callback)` will remove all documents matching `query` according to `options`  \n* `query` is the same as the ones used for finding and updating\n* `options` only one option for now: `multi` which allows the removal of multiple documents if set to true. Default is false\n* `callback` is optional, signature: err, numRemoved\n\n```javascript\n// Let's use the same example collection as in the \"finding document\" part\n// { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false }\n// { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true }\n// { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\n// { _id: 'id4', planet: 'Omicron Persia 8', system: 'futurama', inhabited: true }\n\n// Remove one document from the collection\n// options set to {} since the default for multi is false\nPlanet.remove({ _id: 'id2' }, {}, function (err, numRemoved) {\n  // numRemoved = 1\n});\n\n// Remove multiple documents\nPlanet.remove({ system: 'solar' }, { multi: true }, function (err, numRemoved) {\n  // numRemoved = 3, all planets from the solar system were removed\n});\n```\n\nEvents\n---------------\n\n```javascript\n// Hook-like\nDoc.on('save', function(doc) { }) // Will be called before saving a document - no matter if using save, insert or update methods. You can modify the document in this event, it's essentially a hook\nDoc.on('insert', function(doc) { }) // Will be called before saving a new document - again, no matter if using save/insert/update methods. You can modify the document in this event\nDoc.on('remove', function(doc) { }) // Before removing a document; called with the document about to be removed\n\nDoc.on('construct', function(doc) { }) // When a document is constructed\n\n// After operation is complete\nDoc.on('inserted', function(docs) { }) // Called after inserting new documents is complete; docs is an array of documents\nDoc.on('updated', function(docs) { }) // Called after updating documents is complete; docs is an array of documents\nDoc.on('removed', function(ids) { }) // Called after removing documents is complete; ids is an array of ids\n```\n\n\nSchemas\n------\nYou can define a schema for a model, allowing you to enforce certain properties to types (String, Number, Date), set defaults and also define properties with getter/setter. Since schema support is implemented deep in LinvoDB, you can query on fields which are getter/setter-based and rely that types/defaults are always going to be enforced.\n\n**NOTE: when constructing a model with a schema, please specify options object after the schema, otherwise schema will be treated as options: `new LinvoDB(name, schema, options)`**\n\nSchemas are defined as an object of specs for each property. The spec can have properties:\n\n* `type` - the type to be enforced, can be String, Number, Date along with \"string\", \"number\", \"date\" alternative syntax. Can also be a RegExp instance in case you want to validate against that expression.\n* `default` - the default value; must comply to the type obviously\n* `enumerable` - whether this property will be enumerable\n* `get` - getter, cannot be used with type/default\n* `set` - setter, cannot be used with type/default\n* `index`, `sparse`, `unique` - booleans, whether to create an index and it's options\n\nIf type is all you need, you can shorthand the property to the type only, e.g. `{ name: String }`.\nYou can also define a property as an \"array of\" by setting it to `[spec]`, for example `[String]` for an array of strings.\nNested objects are supported.\n\n```javascript\nvar Person = new LinvoDB(\"person\", { \n\tname: { type: String, default: \"nameless\" }, // default value\n\tage: Number, // shorthand to { type: ... }\n\tcreated: Date, \n\taddress: { // nested object\n\t\tline1: String,\n\t\tline2: String\n\t},\n\tdepartment: { type: String, index: true }, // you can use the schema spec to define indexes\n\tfavNumbers: [Number], // array of\n\tfirstName: { get: function() { return this.name.split(\" \")[0] } }\n}, { });\n\nvar p = new Person();\n// p is { name: 'nameless', age: 0, created: /* date when created */, address: { line1: \"\", line2: \"\" }, favNumbers: [] }\n\np.name = 23;\n// p.name becomes \"23\"\n\np.created = \"10/23/2004\"; \n// p is 23 October 2004, date object\n\np.favNumbers.push(22);\np.favNumbers.push(\"42\"); // favNumbers will be [22, 42] ; the string will be cast to a number\np.favNumbers.push(\"forty five\"); // nothing happens, can't cast\n// p.favNumbers is [22, 42]\n\np.name = \"John Smith\"; \n// p.firstName is \"John\"\n\np.save(function() { \n\t// Person is saved\n\t// You can even query on virtual properties\n\n\tPerson.find({ firstName: \"John\" }, function(err, res) { /* res will be [p] */ });\n});\n```\n\n\n\nModel - static & instance methods\n-----------\n```javascript\n// var doc = new Doc(); // create a new instance\n// Or get it from query results\n\ndoc.remove(function(err) { /* removes the document*/ })\ndoc.save(function(err) { /* saves the document*/ })\ndoc.copy(); // returns a copy of the document\n```\n\nYou can define additional functions for both the model and the document instances.\n```javascript\nPlanet.static(\"findAllSolar\", function(cb) { return Planet.find({ system: 'solar' }).exec(cb) });\nPlanet.findAllSolar(function(err,res) {  /* res is all planets in the solar system */  });\n\nPlanet.method(\"findSameSystem\", function(cb) { return Planet.find({ system: this.system }).exec(cb) });\nPlanet.findOne({ planet: 'Earth' }, function(err, doc) {\n\tdoc.findSameSystem(function(err,res) { /* res is all planets in the solar system */ })\n});\n```\n\n\nIndexing\n----------\nIndexing in LinvoDB is automatic, although you can turn that off (`{autoindex: false}` in model options, not recommended). Defining indexes, in case you need you enforce a unique constraint, happens with `Doc.ensureIndex({ fieldName: \"name\", unique: true })`. \n\nThe full syntax is `Doc.ensureIndex(options, cb)`, where callback is optional and get passed an error if any (usually a unique constraint that was violated). `ensureIndex` can be called when you want, even after some data was inserted, though it's best to call it at application startup. The options are:  \n\n* **fieldName** (required): name of the field to index. Use the dot notation to index a field in a nested document.\n* **unique** (optional, defaults to `false`): enforce field uniqueness. Note that a unique index will raise an error if you try to index two documents for which the field is not defined.\n* **sparse** (optional, defaults to `false`): don't index documents for which the field is not defined. Use this option along with \"unique\" if you want to accept multiple documents for which it is not defined.\n\nYou can remove a previously created index with `Doc.removeIndex(fieldName, cb)`.\n\n**NOTE compound indexes are currently not supported.**\n\n\n\nUtilization\n-------------\n**[Stremio](http://strem.io)** - LinvoDB was created specifically because NeDB started to behave suboptimally with >300 movie/series metadata objects, which were pretty large. Reduced memory usage from ~500MB to ~100MB. Live queries, schemas and map/reduce helped create a much cleaner codebase.\n\n_If you wish to add something here, contact me at ivo@linvo.com_\n\nLicense \n-------------\nSee [License](LICENSE)\n\n\nHelp\n-------------\nPull requests are always welcome. :)\n"
}