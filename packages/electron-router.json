{
  "name": "electron-router",
  "version": "0.4.0",
  "license": "MIT",
  "description": "Router for Electron shell, useful for MVC",
  "author": {
    "name": "Guillermo Blanco"
  },
  "repository": {
    "user": "m0n0l0c0",
    "repo": "electron-router",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/m0n0l0c0/electron-router/tarball/master",
    "clone_url": "https://github.com/m0n0l0c0/electron-router",
    "https_url": "https://github.com/m0n0l0c0/electron-router",
    "travis_url": "https://travis-ci.org/m0n0l0c0/electron-router",
    "zip_url": "https://github.com/m0n0l0c0/electron-router/archive/master.zip",
    "api_url": "https://api.github.com/repos/m0n0l0c0/electron-router"
  },
  "main": "router.js",
  "dependencies": {
    "eventemitter3": "git+https://github.com/m0n0l0c0/eventemitter3.git",
    "node-uuid": "^1.4.7",
    "lodash": "^4.13.1"
  },
  "devDependencies": {
    "electron-mocha": "git+https://github.com/m0n0l0c0/electron-mocha.git#v2.4.0",
    "electron-packager": "^5.1.0",
    "istanbul": "^0.4.5",
    "mocha": "^3.0.2",
    "require-no-cache": "^0.2.1",
    "should": "^9.0.2",
    "standard": "^8.0.0"
  },
  "keywords": [
    "electron",
    "router",
    "mvc",
    "callback"
  ],
  "scripts": {
    "prepublish": "npm test",
    "test-env": "./node_modules/mocha/bin/mocha --require tests/coverage.js tests/env/main.js && mv coverage/coverage-final.json coverage/coverage-env.json",
    "test-config": "./node_modules/electron-mocha/bin/electron-mocha --require tests/coverage.js tests/config/main.js && mv coverage/coverage-final.json coverage/coverage-conf.json",
    "test-errors": "./node_modules/electron-mocha/bin/electron-mocha --require tests/coverage.js tests/errors/params.js && mv coverage/coverage-final.json coverage/coverage-errors.json",
    "test-process": "./node_modules/electron-mocha/bin/electron-mocha --require tests/coverage.js tests/mainProcess/main.js && mv coverage/coverage-final.json coverage/coverage-process.json",
    "test-renderer-alone": "./node_modules/electron-mocha/bin/electron-mocha --require tests/coverage.js --renderer tests/renderer/alone.js && mv coverage/coverage-final.json coverage/coverage-alone.json",
    "test-renderer-complex": "./node_modules/electron-mocha/bin/electron-mocha --require tests/coverage.js --preload tests/renderer/process.js --renderer tests/renderer/renderer.js && mv coverage/coverage-final.json coverage/coverage-complex.json",
    "test": "standard && npm run test-env && npm run test-config && npm run test-errors && npm run test-process && npm run test-renderer-alone && npm run test-renderer-complex && istanbul report"
  },
  "gitHead": "f80cfbc8f9084c9c3746b2044b03870eeb691d67",
  "homepage": "https://github.com/m0n0l0c0/electron-router#readme",
  "_npmVersion": "3.10.7",
  "_nodeVersion": "6.5.0",
  "dist": {
    "shasum": "3f472ef227f9e376b846e90f04dccc0b058ddf5b",
    "tarball": "http://registry.npmjs.org/electron-router/-/electron-router-0.4.0.tgz"
  },
  "stars": 1,
  "versions": [
    {
      "number": "0.1.1",
      "date": "2016-07-30T16:49:44.872Z"
    },
    {
      "number": "0.2.0",
      "date": "2016-08-29T19:07:10.426Z"
    },
    {
      "number": "0.3.0",
      "date": "2016-09-04T15:18:46.877Z"
    },
    {
      "number": "0.3.1",
      "date": "2016-09-09T14:40:13.160Z"
    },
    {
      "number": "0.4.0",
      "date": "2016-09-18T19:26:05.096Z"
    }
  ],
  "created": "2016-07-30T16:49:44.872Z",
  "modified": "2016-09-18T19:26:05.096Z",
  "lastPublisher": {
    "name": "m0n0l0c0",
    "email": "guillermoechegoyenblanco@gmail.com"
  },
  "owners": [
    {
      "name": "m0n0l0c0",
      "email": "guillermoechegoyenblanco@gmail.com"
    }
  ],
  "readme": "# ElectronRouter\n\n[![codecov](https://codecov.io/gh/m0n0l0c0/electron-router/branch/master/graph/badge.svg)](https://codecov.io/gh/m0n0l0c0/electron-router)\n[![JavaScript Style Guide](https://img.shields.io/badge/code%20style-standard-brightgreen.svg)](http://standardjs.com/)\n\nRouter solving Electron shell callback passing, helpfull for MVC\n\n# Contents\n- [Motivation](#motivation) \n- [Features](#features)\n- [API](#api)\n- [Examples](#examples)\n- [Contributing](#contributing)\n- [Future](#future)\n- [Notes](#notes)\n\n## Installation\n\n```\n// Install:\nnpm install electron-router\n\n// Test:\nnpm test\n```\n\n## Motivation\n### The problem\nWhen making an electron app I usually come down to the same problem: message passing; if you want to send a message to a window you have to keep a reference to it, whatever the module you're sending the message from, which leaves two possible solutions:\n* Pass the wanted window object to every module that needs to send a message to that window.\n\nor\n\n* Somehow send the message to the owner of the window reference (usually implies callback passing).\n\nOn the other hand, when you want to receive a message from the window you have to listen to ipc which is usually great, but forces you to have perfect tune of the variables that the callback is going to access; this does not present a problem by itself, but as the application grows it may become one.\n\nOne example of this is when you have a database and want to query it from the window renderer process, either the database is listening on the ipc and aware of the window (keeps a reference to it) for querying/retrieving data or both the window and the database route their data through the main script, becoming some sort of dummy proxy.\n\nAfter some brainstorming, the solution I came to was designing the Router, it gives similar options to [express](http://expressjs.com/). I've made a diagram to help visualize all this.\n\n![problem solution](router.png)\n\n### The solution\nThe router just triggers the functions you register on by sending events and parameters. Allowing easy message/data passing and respecting the event/callback Electron architecture.\n\n## Features\n\n### Wildcards\nEvery sent/listened message can use wildcards\n```\nrouter.on('loading::start', () => { console.log('start loading...') }\nrouter.on('loading::continue', () => { console.log('continue loading...') }\nrouter.on('loading::end', () => { console.log('end loading...') }\n\n...\n\nrouter.send('loading::start', ...) // logs \"start loading\"\nrouter.send('loading::*', ...) // logs \"start loading\", \"continue loading\", \"end loading\"\n\n```\n\n#### Simple, plain communication\nYou can send messages unidirectionally from the main process to the renderer process and viceversa (analogous to electron's ipc) (Previous example)\n\n#### Duplex communication with channels\n\n```\nrouter.get('config::*')\nrouter.post('config', ( req, res ) => {\n\t// req.params contain sent parameters\n\t// res.json sends data back\n})\n...\n\nrouter.route('get', 'config::start', ( err, result ) => {\n\tconsole.log('got config', result)\n})\n```\n\n## API\n\nThe router is just a static object, there will be one router in the main process and another one on the renderer. Just 'require' it and start listening/sending events/data. What this object does is route callbacks from one side to another passing parameters, triggered by different events.\nIt can listen to ipc events and send window events too.\nHTTP Verbs are used just as different channels and for completness (equality to express)\nFor every route/event it is possible register wildcard ('*')\n\n#### Instance\n```\n// Constructs the object setting its name\nlet Router = require('electron-router')\n\n// Returns the static instance\nlet router = Router( name )\n```\n\n#### Simple communication\n```\n// Triggers/Sends a message on the given event name passing provided messages.\nrouter.send( event, msg1, msg2... )\n\n// Register a listener on the given event, triggering the callback when the event is sent.\n// Callback receives the messages sent on the other side\nrouter.on( event, ( msg1, msg2... ) => {})\n```\n\n#### Duplex communication\n```\n// Triggers/Sends a message to the given route on the given method (channel, HTTP Verbs)\n// passing the given messages to that channel/route handler. \n// Callback is called with err/result when the handler calls res.json()\n// if the handler does not call the return function, callback is invoked with Err: Timeout\n\nrouter.route( method, route, msg1, msg2..., ( err, result ) => {})\n\n// Similar to router.routes.method( route, msg1, msg2..., ( err, result ) => {})\n\n// All handlers on all channels are called with\n// \treq { parameters: [], method: channel }\n// \tres { json: [Function] } - function to call with (err, result), triggers the route back\n\n// Registers handler on GET channel at the given route.\nrouter.get( route, ( req, res ) => {}) // must call res.json( err, result )\n\n// Registers handler on POST channel at the given route.\nrouter.post( route, ( req, res ) => {}) // must call res.json( err, result )\n\n// Registers handler on UPDATE channel at the given route.\nrouter.update( route, ( req, res ) => {}) // must call res.json( err, result )\n\n// Registers handler on DELETE channel at the given route.\nrouter.delete( route, ( req, res ) => {}) // must call res.json( err, result )\n\n```\n\n## Examples\n\n```\n// On every module that uses the router\n// Import it\nlet Router = require('electron-router')\n\n// Main script\n\ncons electron = require('electron')\nconst BrowserWindow = electron.BrowserWindow\nconst app = electron.app\nconst Router = require('electron-router')\nlet router = Router('MAIN')\nlet mainWindow = null\n\n...\n\napp.on('ready', () => {\n\n\t// Create window\n\t... \n\n  // Setup DB and modules\n  ...\n\n\t// Do the rest on ready event (triggered from window, which is usaully the slowest component)\n\trouter.on('ready', () => {\n\t\trouter.on('quit', () => {\n\t\t\t// Close DB\n\t\t\t// Handle quit code\n\t\t\t...\n\t\t})\n\t})\n})\n\n...\n\n// Window script\n\nconst $ = require('jquery')\nconst Router = require('electron-router')\nlet router = Router('WINDOW')\n\n// On window ready\n$(() => {\n  // Send ready event to all registered handlers\n  router.send('ready')\n  ...\n\n  $('#updates').on('click', () => {\n  \trouter.route('POST', '/DB', $('#userData').data())\n  })\n})\n\n...\n\n// DB script\n\nconst Router = require('electron-router')\nlet router = Router('DB')\n\n...\n\nrouter.on('ready', () => { ... })\n\n// Register trigger for every route on method GET\nroute.get('*', ( req, res ) => {\n\tdb.find({ id: req.params }, ( err, results ) => {\n\t\tres.json( err, results )\n\t})\n})\n\n// Receive data on post method, route /DB\nrouter.post('/DB', ( req, res ) => {\n\tconsole.log('Received', req.params)\n\t// Save data on db\n\tdb.save( req.params, ( err, result ) => {\n\t\t// Send save result to the triggerer\n\t\tres.json( err, result )\n\t})\n})\n\n```\n\n## Contributing\nAny help is welcome, just send a pull request (please document a little what you want to do), with any ideas/code\n\n## Future\nIn the future it could be great to support:\n* MVC frameworks integration (Backbone...) (Should not be too difficult, overwrite sync method on Collections)\n* Template rendering (i.e.: ```res.render(data)```)\n\n## Notes\nThe diagram was made with [gliffy](https://www.gliffy.com/)\n"
}