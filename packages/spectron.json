{
  "name": "spectron",
  "version": "3.2.6",
  "description": "Easily test your Electron apps using ChromeDriver and WebdriverIO.",
  "main": "index.js",
  "scripts": {
    "test": "standard && mocha"
  },
  "engines": {
    "node": ">=0.12.4"
  },
  "repository": {
    "user": "electron",
    "repo": "spectron",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/electron/spectron/tarball/master",
    "clone_url": "https://github.com/electron/spectron",
    "https_url": "https://github.com/electron/spectron",
    "travis_url": "https://travis-ci.org/electron/spectron",
    "zip_url": "https://github.com/electron/spectron/archive/master.zip",
    "api_url": "https://api.github.com/repos/electron/spectron"
  },
  "keywords": [
    "electron",
    "chromedriver",
    "webdriverio",
    "selenium"
  ],
  "author": {
    "name": "Kevin Sawicki"
  },
  "license": "MIT",
  "homepage": "https://github.com/electron/spectron#readme",
  "dependencies": {
    "dev-null": "^0.1.1",
    "electron-chromedriver": "~1.2.1",
    "request": "^2.65.0",
    "split": "^1.0.0",
    "webdriverio": "^4.0.4"
  },
  "devDependencies": {
    "chai": "^3.3.0",
    "chai-as-promised": "^5.1.0",
    "electron-prebuilt": "~1.2.0",
    "mocha": "^2.3.3",
    "standard": "^5.3.1",
    "temp": "^0.8.3"
  },
  "gitHead": "a21f04066eae3c7a0fc20ac70eea6086640bbf0e",
  "_npmVersion": "2.10.1",
  "_nodeVersion": "0.12.4",
  "dist": {
    "shasum": "5bfcf090f5638bfd28155de420b62d5a3f28d769",
    "tarball": "http://registry.npmjs.org/spectron/-/spectron-3.2.6.tgz"
  },
  "versions": [
    {
      "number": "0.33.0",
      "date": "2015-10-13T01:05:15.329Z"
    },
    {
      "number": "0.33.1",
      "date": "2015-10-13T23:25:12.897Z"
    },
    {
      "number": "0.33.2",
      "date": "2015-10-15T04:10:36.066Z"
    },
    {
      "number": "0.33.3",
      "date": "2015-10-18T18:10:12.524Z"
    },
    {
      "number": "0.33.4",
      "date": "2015-10-29T19:26:19.345Z"
    },
    {
      "number": "0.33.5",
      "date": "2015-10-30T15:59:33.749Z"
    },
    {
      "number": "0.33.6",
      "date": "2015-11-03T23:08:59.845Z"
    },
    {
      "number": "0.34.0",
      "date": "2015-11-05T17:32:08.096Z"
    },
    {
      "number": "0.34.1",
      "date": "2015-11-10T19:19:22.345Z"
    },
    {
      "number": "0.35.0",
      "date": "2015-12-02T23:22:25.437Z"
    },
    {
      "number": "0.35.1",
      "date": "2015-12-03T02:19:45.029Z"
    },
    {
      "number": "0.35.2",
      "date": "2015-12-03T02:50:45.074Z"
    },
    {
      "number": "0.35.3",
      "date": "2015-12-03T16:37:00.443Z"
    },
    {
      "number": "0.35.4",
      "date": "2015-12-12T18:02:08.169Z"
    },
    {
      "number": "0.35.5",
      "date": "2015-12-13T20:59:00.271Z"
    },
    {
      "number": "0.36.0",
      "date": "2015-12-14T02:39:23.901Z"
    },
    {
      "number": "0.36.1",
      "date": "2016-02-04T20:59:37.406Z"
    },
    {
      "number": "0.37.0",
      "date": "2016-03-14T22:18:36.245Z"
    },
    {
      "number": "1.37.0",
      "date": "2016-03-21T22:04:56.803Z"
    },
    {
      "number": "2.37.0",
      "date": "2016-04-26T22:03:49.344Z"
    },
    {
      "number": "3.0.0",
      "date": "2016-05-11T06:27:13.102Z"
    },
    {
      "number": "3.0.1",
      "date": "2016-05-19T17:41:28.013Z"
    },
    {
      "number": "3.1.0",
      "date": "2016-05-19T18:09:23.649Z"
    },
    {
      "number": "3.1.1",
      "date": "2016-05-27T00:08:39.396Z"
    },
    {
      "number": "3.1.2",
      "date": "2016-05-27T19:24:07.539Z"
    },
    {
      "number": "3.1.3",
      "date": "2016-05-31T20:24:37.423Z"
    },
    {
      "number": "3.2.0",
      "date": "2016-05-31T20:43:56.879Z"
    },
    {
      "number": "3.2.1",
      "date": "2016-06-02T18:19:28.680Z"
    },
    {
      "number": "3.2.2",
      "date": "2016-06-02T20:38:46.456Z"
    },
    {
      "number": "3.2.3",
      "date": "2016-06-06T16:37:03.667Z"
    },
    {
      "number": "3.2.4",
      "date": "2016-06-30T21:36:02.337Z"
    },
    {
      "number": "3.2.5",
      "date": "2016-07-06T22:28:33.172Z"
    },
    {
      "number": "3.2.6",
      "date": "2016-07-08T17:25:00.692Z"
    }
  ],
  "created": "2015-10-13T01:05:15.329Z",
  "modified": "2016-07-08T17:25:00.692Z",
  "lastPublisher": {
    "name": "kevinsawicki",
    "email": "kevinsawicki@gmail.com"
  },
  "owners": [
    {
      "name": "jlord",
      "email": "to.jlord@gmail.com"
    },
    {
      "name": "kevinsawicki",
      "email": "kevinsawicki@gmail.com"
    },
    {
      "name": "zcbenz",
      "email": "zcbenz@gmail.com"
    },
    {
      "name": "zeke",
      "email": "zeke@sikelianos.com"
    }
  ],
  "readme": "# <img src=\"https://cloud.githubusercontent.com/assets/378023/15063284/cf544f2c-1383-11e6-9336-e13bd64b1694.png\" width=\"60px\" align=\"center\" alt=\"Spectron icon\"> Spectron\n\n[![Linux Build Status](https://travis-ci.org/electron/spectron.svg?branch=master)](https://travis-ci.org/electron/spectron)\n[![Windows Build Status](https://ci.appveyor.com/api/projects/status/iv8xd919q6b44pap/branch/master?svg=true)](https://ci.appveyor.com/project/kevinsawicki/spectron/branch/master)\n<br>\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](http://standardjs.com/)\n[![devDependencies:?](https://img.shields.io/david/electron/spectron.svg)](https://david-dm.org/electron/spectron)\n<br>\n[![license:mit](https://img.shields.io/badge/license-mit-blue.svg)](https://opensource.org/licenses/MIT)\n[![npm:](https://img.shields.io/npm/v/spectron.svg)](https://www.npmjs.com/packages/spectron)\n[![dependencies:?](https://img.shields.io/npm/dm/spectron.svg)](https://www.npmjs.com/packages/spectron)\n\nEasily test your [Electron](http://electron.atom.io) apps using\n[ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver) and\n[WebdriverIO](http://webdriver.io).\n\nThis minor version of this library tracks the minor version of the Electron\nversions released. So if you are using Electron `1.0.x` you would want to use\na `spectron` dependency of `~3.0.0` in your `package.json` file.\n\nLearn more from [this presentation](https://speakerdeck.com/kevinsawicki/testing-your-electron-apps-with-chromedriver).\n\n:rotating_light: Upgrading from `1.x` to `2.x`/`3.x`? Read the [changelog](https://github.com/electron/spectron/blob/master/CHANGELOG.md).\n\n## Using\n\n```sh\nnpm install --save-dev spectron\n```\n\nSpectron works with any testing framework but the following example uses\n[mocha](https://mochajs.org):\n\n```js\nvar Application = require('spectron').Application\nvar assert = require('assert')\n\ndescribe('application launch', function () {\n  this.timeout(10000)\n\n  beforeEach(function () {\n    this.app = new Application({\n      path: '/Applications/MyApp.app/Contents/MacOS/MyApp'\n    })\n    return this.app.start()\n  })\n\n  afterEach(function () {\n    if (this.app && this.app.isRunning()) {\n      return this.app.stop()\n    }\n  })\n\n  it('shows an initial window', function () {\n    return this.app.client.getWindowCount().then(function (count) {\n      assert.equal(count, 1)\n    })\n  })\n})\n```\n\n## Application API\n\nSpectron exports an `Application` class that when configured, can start and\nstop your Electron application.\n\n### new Application(options)\n\nCreate a new application with the following options:\n\n* `path` -  **Required.** String path to the application executable to launch. If you want to invoke electron with a particular script, which hasn't been packaged into single executable, `path` must point to electron, while the very first argument in `args` must be script's path.\n* `args` - Array of arguments to pass to the executable.\n  See [here](https://sites.google.com/a/chromium.org/chromedriver/capabilities)\n  for details on the Chrome arguments.\n* `cwd`- String path to the working directory to use for the launched\n  application. Defaults to `process.cwd()`.\n* `env` - Object of additional environment variables to set in the launched\n  application.\n* `host` - String host name of the launched `chromedriver` process.\n  Defaults to `'localhost'`.\n* `port` - Number port of the launched `chromedriver` process.\n  Defaults to `9515`.\n* `nodePath` - String path to a `node` executable to launch ChromeDriver with.\n  Defaults to `process.execPath`.\n* `connectionRetryCount` - Number of retry attempts to make when connecting\n  to ChromeDriver. Defaults to `10` attempts.\n* `connectionRetryTimeout` - Number in milliseconds to wait for connections\n  to ChromeDriver to be made. Defaults to `30000` milliseconds.\n* `quitTimeout` - Number in milliseconds to wait for application quitting.\n  Defaults to `1000` milliseconds.\n* `requireName` - Custom property name to use when requiring modules. Defaults\n  to `require`. This should only be used if your application deletes the main\n  `window.require` function and assigns it to another property name on `window`.\n* `startTimeout` - Number in milliseconds to wait for ChromeDriver to start.\n  Defaults to `5000` milliseconds.\n* `waitTimeout` - Number in milliseconds to wait for calls like\n  `waitUntilTextExists` and `waitUntilWindowLoaded` to complete.\n  Defaults to `5000` milliseconds.\n* `debuggerAddress` - String address of a Chrome debugger server to connect to.\n* `chromeDriverLogPath` - String path to file to store ChromeDriver logs in.\n  Setting this option enables `--verbose` logging when starting ChromeDriver.\n\n### Node Integration\n\nThe Electron helpers provided by Spectron require accessing the core Electron\nAPIs in the renderer processes of your application. So if your Electron\napplication has `nodeIntegration` set to `false` then you'll need to expose a\n`require` window global to Spectron so it can access the core Electron APIs.\n\nYou can do this by adding a [`preload`][preload] script that does the following:\n\n```js\nif (process.env.NODE_ENV === 'test') {\n  window.electronRequire = require\n}\n```\n\nThen create the Spectron `Application` with the `requireName` option set to\n`'electronRequire'` and then runs your tests via `NODE_ENV=test npm test`.\n\n**Note:** This is only required if you tests are accessing any Electron APIs.\nYou don't need to do this if you are only accessing the helpers on the `client`\nproperty which do not require Node integration.\n\n### Properties\n\n#### client\n\nSpectron uses [WebdriverIO](http://webdriver.io) and exposes the managed\n`client` property on the created `Application` instances.\n\nThe full `client` API provided by WebdriverIO can be found\n[here](http://webdriver.io/api.html).\n\nSeveral additional commands are provided specific to Electron.\n\nAll the commands return a `Promise`.\n\nSo if you wanted to get the text of an element you would do:\n\n```js\napp.client.getText('#error-alert').then(function (errorText) {\n  console.log('The #error-alert text content is ' + errorText)\n})\n```\n\n#### electron\n\nThe `electron` property is your gateway to accessing the full Electron API.\n\nEach Electron module is exposed as a property on the `electron` property\nso you can think of it as an alias for `require('electron')` from within your\napp.\n\nSo if you wanted to access the [clipboard](http://electron.atom.io/docs/latest/api/clipboard)\nAPI in your tests you would do:\n\n```js\napp.electron.clipboard.writeText('pasta')\n   .electron.clipboard.readText().then(function (clipboardText) {\n     console.log('The clipboard text is ' + clipboardText)\n   })\n```\n\n#### browserWindow\n\nThe `browserWindow` property is an alias for `require('electron').remote.getCurrentWindow()`.\n\nIt provides you access to the current [BrowserWindow](http://electron.atom.io/docs/latest/api/browser-window/)\nand contains all the APIs.\n\nSo if you wanted to check if the current window is visible in your tests you\nwould do:\n\n```js\napp.browserWindow.isVisible().then(function (visible) {\n  console.log('window is visible? ' + visible)\n})\n```\n\nIt is named `browserWindow` instead of `window` so that it doesn't collide\nwith the WebDriver command of that name.\n\n##### capturePage\n\nThe async `capturePage` API is supported but instead of taking a callback it\nreturns a `Promise` that resolves to a `Buffer` that is the image data of\nscreenshot.\n\n```js\napp.browserWindow.capturePage().then(function (imageBuffer) {\n  fs.writeFile('page.png', imageBuffer)\n})\n```\n\n#### webContents\n\nThe `webContents` property is an alias for `require('electron').remote.getCurrentWebContents()`.\n\nIt provides you access to the [WebContents](http://electron.atom.io/docs/latest/api/web-contents/)\nfor the current window and contains all the APIs.\n\nSo if you wanted to check if the current window is loading in your tests you\nwould do:\n\n```js\napp.webContents.isLoading().then(function (visible) {\n  console.log('window is loading? ' + visible)\n})\n```\n\n##### savePage\n\nThe async `savePage` API is supported but instead of taking a callback it\nreturns a `Promise` that will raise any errors and resolve to `undefined` when\ncomplete.\n\n```js\napp.webContents.savePage('/Users/kevin/page.html', 'HTMLComplete')\n  .then(function () {\n    console.log('page saved')\n  }).catch(function (error) {\n    console.error('saving page failed', error.message)\n  })\n```\n\n#### mainProcess\n\nThe `mainProcess` property is an alias for `require('electron').remote.process`.\n\nIt provides you access to the main process's [process](https://nodejs.org/api/process.html)\nglobal.\n\nSo if you wanted to get the `argv` for the main process in your tests you would\ndo:\n\n```js\napp.mainProcess.argv().then(function (argv) {\n  console.log('main process args: ' + argv)\n})\n```\n\nProperties on the `process` are exposed as functions that return promises so\nmake sure to call `mainProcess.env().then(...)` instead of\n`mainProcess.env.then(...)`.\n\n#### rendererProcess\n\nThe `rendererProcess` property is an alias for `global.process`.\n\nIt provides you access to the renderer process's [process](https://nodejs.org/api/process.html)\nglobal.\n\nSo if you wanted to get the environment variables for the renderer process in\nyour tests you would do:\n\n```js\napp.rendererProcess.env().then(function (env) {\n  console.log('main process args: ' + env)\n})\n```\n\n### Methods\n\n#### start()\n\nStarts the application. Returns a `Promise` that will be resolved when the\napplication is ready to use. You should always wait for start to complete\nbefore running any commands.\n\n#### stop()\n\nStops the application. Returns a `Promise` that will be resolved once the\napplication has stopped.\n\n#### restart()\n\nStops the application and then starts it. Returns a `Promise` that will be\nresolved once the application has started again.\n\n#### client.getMainProcessLogs()\n\nGets the `console` log output from the main process. The logs are cleared\nafter they are returned.\n\nReturns a `Promise` that resolves to an array of string log messages\n\n```js\napp.client.getMainProcessLogs().then(function (logs) {\n  logs.forEach(function (log) {\n    console.log(log)\n  })\n})\n```\n\n#### client.getRenderProcessLogs()\n\nGets the `console` log output from the render process. The logs are cleared\nafter they are returned.\n\nReturns a `Promise` that resolves to an array of log objects.\n\n```js\napp.client.getRenderProcessLogs().then(function (logs) {\n  logs.forEach(function (log) {\n    console.log(log.message)\n    console.log(log.source)\n    console.log(log.level)\n  })\n})\n```\n\n#### client.getSelectedText()\n\nGet the selected text in the current window.\n\n```js\napp.client.getSelectedText().then(function (selectedText) {\n  console.log(selectedText)\n})\n```\n\n#### client.getWindowCount()\n\nGets the number of open windows.\n`<webview>` tags are also counted as separate windows.\n\n```js\napp.client.getWindowCount().then(function (count) {\n  console.log(count)\n})\n```\n\n#### client.waitUntilTextExists(selector, text, [timeout])\n\nWaits until the element matching the given selector contains the given\ntext. Takes an optional timeout in milliseconds that defaults to `5000`.\n\n```js\napp.client.waitUntilTextExists('#message', 'Success', 10000)\n```\n\n#### client.waitUntilWindowLoaded([timeout])\n\nWait until the window is no longer loading. Takes an optional timeout\nin milliseconds that defaults to `5000`.\n\n```js\napp.client.waitUntilWindowLoaded(10000)\n```\n\n#### client.windowByIndex(index)\n\nFocus a window using its index from the `windowHandles()` array.\n`<webview>` tags can also be focused as a separate window.\n\n```js\napp.client.windowByIndex(1)\n```\n\n### Accessibility Testing\n\nSpectron bundles the [Accessibility Developer Tools](https://github.com/GoogleChrome/accessibility-developer-tools)\nprovided by Google and adds support for auditing each window and `<webview>`\ntag in your application.\n\n#### client.auditAccessibility(options)\n\nRun an accessibility audit in the focused window with the specified options.\n\n* `options` - An optional Object with the following keys:\n  * `ignoreWarnings` - `true` to ignore failures with a severity of `'Warning'`\n    and only include failures with a severity of `'Severe'`. Defaults to `false`.\n  * `ignoreRules` - Array of String rule code values such as `AX_COLOR_01` to\n    ignore failures for. The full list is available [here](https://github.com/GoogleChrome/accessibility-developer-tools/wiki/Audit-Rules).\n\nReturns an `audit` Object with the following properties:\n\n* `message` - A detailed String message about the results\n* `failed` - A Boolean, `false` when the audit has failures\n* `results` - An array of detail objects for each failed rule. Each object\n  in the array has the following properties:\n  * `code` - A unique String accessibility rule identifier\n  * `elements` - An Array of Strings representing the selector path of each\n    HTML element that failed the rule\n  * `message` - A String message about the failed rule\n  * `severity` - `'Warning'` or `'Severe'`\n  * `url` - A String URL providing more details about the failed rule\n\n```js\napp.client.auditAccessibility().then(function (audit) {\n  if (audit.failed) {\n    console.error(audit.message)\n  }\n})\n```\n\nSee https://github.com/GoogleChrome/accessibility-developer-tools/wiki/Audit-Rules\nfor more details about the audit rules.\n\nIf you are using a `<webview>` tag in your app and want to audit both the outer\npage and the `<webview>`'s page then you will need to do the following:\n\n```js\n// Focus main page and audit it\napp.client.windowByIndex(0).then(function() {\n  app.client.auditAccessibility().then(function (audit) {\n    if (audit.failed) {\n      console.error('Main page failed audit')\n      console.error(audit.message)\n    }\n\n    //Focus <webview> tag and audit it\n    app.client.windowByIndex(1).then(function() {\n      app.client.auditAccessibility().then(function () {\n        if (audit.failed) {\n          console.error('<webview> page failed audit')\n          console.error(audit.message)\n        }\n      })\n    })\n  })\n})\n```\n\n## Continuous Integration\n\n### On Travis CI\n\nYou will want to add the following to your `.travis.yml` file when building on\nLinux:\n\n```yml\nbefore_script:\n  - \"export DISPLAY=:99.0\"\n  - \"sh -e /etc/init.d/xvfb start\"\n  - sleep 3 # give xvfb some time to start\n```\n\nCheck out Spectron's [.travis.yml](https://github.com/electron/spectron/blob/master/.travis.yml)\nfile for a production example.\n\n### On AppVeyor\n\nYou will want to add the following to your `appveyor.yml` file:\n\n```yml\nos: unstable\n```\n\nCheck out Spectron's [appveyor.yml](https://github.com/electron/spectron/blob/master/appveyor.yml)\nfile for a production example.\n\n\n## Test Library Examples\n\n### With Chai As Promised\n\nWebdriverIO is promise-based and so it pairs really well with the\n[Chai as Promised](https://github.com/domenic/chai-as-promised) library that\nbuilds on top of [Chai](http://chaijs.com).\n\nUsing these together allows you to chain assertions together and have fewer\ncallback blocks. See below for a simple example:\n\n```sh\nnpm install --save-dev chai\nnpm install --save-dev chai-as-promised\n```\n\n```js\nvar Application = require('spectron').Application\nvar chai = require('chai')\nvar chaiAsPromised = require('chai-as-promised')\nvar path = require('path')\n\nchai.should()\nchai.use(chaiAsPromised)\n\ndescribe('application launch', function () {\n  beforeEach(function () {\n    this.app = new Application({\n      path: '/Applications/MyApp.app/Contents/MacOS/MyApp'\n    })\n    return this.app.start()\n  })\n\n  beforeEach(function () {\n    chaiAsPromised.transferPromiseness = this.app.transferPromiseness\n  })\n\n  afterEach(function () {\n    if (this.app && this.app.isRunning()) {\n      return this.app.stop()\n    }\n  })\n\n  it('opens a window', function () {\n    return this.app.client.waitUntilWindowLoaded()\n      .getWindowCount().should.eventually.equal(1)\n      .browserWindow.isMinimized().should.eventually.be.false\n      .browserWindow.isDevToolsOpened().should.eventually.be.false\n      .browserWindow.isVisible().should.eventually.be.true\n      .browserWindow.isFocused().should.eventually.be.true\n      .browserWindow.getBounds().should.eventually.have.property('width').and.be.above(0)\n      .browserWindow.getBounds().should.eventually.have.property('height').and.be.above(0)\n  })\n})\n```\n\n### With AVA\n\nSpectron works with [AVA](https://github.com/avajs/ava), which allows you\nto write your tests in ES2015+ without doing any extra work.\n\n```js\nimport test from 'ava';\nimport {Application} from 'spectron';\n\ntest.beforeEach(t => {\n  t.context.app = new Application({\n    path: '/Applications/MyApp.app/Contents/MacOS/MyApp'\n  });\n\n  return t.context.app.start();\n});\n\ntest.afterEach(t => {\n  return t.context.app.stop();\n});\n\ntest(t => {\n  return t.context.app.client.waitUntilWindowLoaded()\n    .getWindowCount().then(count => {\n      t.is(count, 1);\n    }).browserWindow.isMinimized().then(min => {\n      t.false(min);\n    }).browserWindow.isDevToolsOpened().then(opened => {\n      t.false(opened);\n    }).browserWindow.isVisible().then(visible => {\n      t.true(visible);\n    }).browserWindow.isFocused().then(focused => {\n      t.true(focused);\n    }).browserWindow.getBounds().then(bounds => {\n      t.true(bounds.width > 0);\n      t.true(bounds.height > 0);\n    });\n});\n```\n\nAVA has built-in support for [async functions](https://github.com/avajs/ava#async-function-support), which simplifies async operations:\n\n```js\nimport test from 'ava';\nimport {Application} from 'spectron';\n\ntest.beforeEach(async t => {\n  t.context.app = new Application({\n    path: '/Applications/MyApp.app/Contents/MacOS/MyApp'\n  });\n\n  await t.context.app.start();\n});\n\ntest.afterEach.always(async t => {\n  await t.context.app.stop();\n});\n\ntest(async t => {\n  const app = t.context.app;\n  await app.client.waitUntilWindowLoaded();\n\n  const win = app.browserWindow;\n  t.is(await app.client.getWindowCount(), 1);\n  t.false(await win.isMinimized());\n  t.false(await win.isDevToolsOpened());\n  t.true(await win.isVisible());\n  t.true(await win.isFocused());\n\n  const {width, height} = await win.getBounds();\n  t.true(width > 0);\n  t.true(height > 0);\n});\n```\n\n[preload]: http://electron.atom.io/docs/api/browser-window/#new-browserwindowoptions\n"
}