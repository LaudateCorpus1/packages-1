{
  "name": "electron-remote",
  "version": "1.0.6",
  "description": "Execute JavaScript in remote Electron processes, but more betterer",
  "scripts": {
    "doc": "esdoc -c ./esdoc.json",
    "compile": "git clean -xdf ./lib && babel -d lib/ src/ && cp ./src/*.html ./lib/",
    "prepublish": "npm run compile",
    "test-renderer": "electron-mocha --renderer --require ./test/support.js ./test",
    "test-browser": "electron-mocha --require ./test/support.js ./test/renderer-require",
    "test": "npm run test-renderer && npm run test-browser",
    "node": "cross-env ELECTRON_RUN_AS_NODE=1 ./node_modules/electron-prebuilt-compile/node_modules/.bin/electron"
  },
  "repository": {
    "user": "paulcbetts",
    "repo": "electron-remote",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/paulcbetts/electron-remote/tarball/master",
    "clone_url": "https://github.com/paulcbetts/electron-remote",
    "https_url": "https://github.com/paulcbetts/electron-remote",
    "travis_url": "https://travis-ci.org/paulcbetts/electron-remote",
    "zip_url": "https://github.com/paulcbetts/electron-remote/archive/master.zip",
    "api_url": "https://api.github.com/repos/paulcbetts/electron-remote"
  },
  "keywords": [
    "remote",
    "electron",
    "rx"
  ],
  "author": {
    "name": "Paul Betts",
    "email": "paul@paulbetts.org"
  },
  "license": "MIT",
  "main": "lib/index.js",
  "homepage": "https://github.com/paulcbetts/electron-remote",
  "dependencies": {
    "debug": "^2.2.0",
    "debug-electron": "^0.0.2",
    "pify": "^2.3.0",
    "rxjs": "^5.0.0-beta.12",
    "xmlhttprequest": "^1.8.0"
  },
  "devDependencies": {
    "babel-cli": "^6.16.0",
    "babel-eslint": "^7.0.0",
    "babel-plugin-transform-async-to-generator": "^6.16.0",
    "babel-plugin-transform-runtime": "^6.15.0",
    "babel-preset-es2016-node5": "^1.1.2",
    "babel-register": "^6.16.3",
    "chai": "^3.5.0",
    "chai-as-promised": "^6.0.0",
    "cross-env": "^3.0.0",
    "electron-mocha": "^3.1.1",
    "electron-prebuilt-compile": "1.4.1",
    "esdoc": "^0.4.8",
    "esdoc-es7-plugin": "0.0.3",
    "esdoc-plugin-async-to-sync": "^0.5.0",
    "eslint": "^3.7.1"
  },
  "gitHead": "978f26c5a3c731106224cc8746761aa9f0a9e69e",
  "_npmVersion": "3.10.8",
  "_nodeVersion": "6.8.0",
  "dist": {
    "shasum": "05c77d3e8cf1e3ce77233c7ef0d503777ae1b9f3",
    "tarball": "http://registry.npmjs.org/electron-remote/-/electron-remote-1.0.6.tgz"
  },
  "stars": 2,
  "versions": [
    {
      "number": "0.5.0",
      "date": "2016-04-28T18:01:06.498Z"
    },
    {
      "number": "0.5.1",
      "date": "2016-05-02T22:31:08.817Z"
    },
    {
      "number": "0.5.2",
      "date": "2016-05-24T21:55:55.590Z"
    },
    {
      "number": "0.5.3",
      "date": "2016-05-24T23:06:24.764Z"
    },
    {
      "number": "0.5.4",
      "date": "2016-05-25T04:34:05.952Z"
    },
    {
      "number": "0.5.5",
      "date": "2016-06-03T23:53:22.849Z"
    },
    {
      "number": "0.5.6",
      "date": "2016-06-04T00:06:01.762Z"
    },
    {
      "number": "0.5.7",
      "date": "2016-07-28T22:13:31.602Z"
    },
    {
      "number": "0.5.8",
      "date": "2016-07-28T22:29:02.910Z"
    },
    {
      "number": "0.5.9",
      "date": "2016-07-28T23:57:07.022Z"
    },
    {
      "number": "0.5.10",
      "date": "2016-07-29T22:40:32.633Z"
    },
    {
      "number": "0.6.0",
      "date": "2016-08-10T00:46:41.873Z"
    },
    {
      "number": "0.6.1",
      "date": "2016-08-10T01:03:08.227Z"
    },
    {
      "number": "0.6.2",
      "date": "2016-08-15T23:14:32.005Z"
    },
    {
      "number": "1.0.0",
      "date": "2016-10-04T00:04:19.503Z"
    },
    {
      "number": "1.0.1",
      "date": "2016-10-04T00:14:48.808Z"
    },
    {
      "number": "1.0.2",
      "date": "2016-10-04T19:36:20.942Z"
    },
    {
      "number": "1.0.3",
      "date": "2016-10-04T20:00:16.456Z"
    },
    {
      "number": "1.0.4",
      "date": "2016-11-09T21:31:44.042Z"
    },
    {
      "number": "1.0.5",
      "date": "2016-11-09T21:50:16.729Z"
    },
    {
      "number": "1.0.6",
      "date": "2016-11-13T01:03:15.504Z"
    }
  ],
  "created": "2016-04-28T18:01:06.498Z",
  "modified": "2016-11-13T01:03:15.504Z",
  "lastPublisher": {
    "name": "paulcbetts",
    "email": "paul@paulbetts.org"
  },
  "owners": [
    {
      "name": "paulcbetts",
      "email": "paul@paulbetts.org"
    }
  ],
  "readme": "# electron-remote: an asynchronous 'remote', and more\r\n\r\n![](https://img.shields.io/npm/dm/electron-remote.svg) <a href=\"http://paulcbetts.github.io/electron-remote/docs\">![](http://paulcbetts.github.io/electron-remote/docs/badge.svg)</a>\r\n\r\n\r\nelectron-remote provides an alternative to Electron's `remote` module based around Promises instead of synchronous execution. It also provides an automatic way to use BrowserWindows as \"background processes\" that auto-scales based on usage, similar to Grand Central Dispatch or the .NET TPL Taskpool.\r\n\r\n## The Quickest of Quick Starts\r\n\r\n###### Calling code in other windows\r\n\r\n```js\r\nimport { createProxyForRemote } from 'electron-remote';\r\n\r\n// myWindowJs is now a proxy object for myWindow's `window` global object\r\nconst myWindowJs = createProxyForRemote(myWindow);\r\n\r\n// Functions suffixed with _get will read a value\r\nuserAgent = await myWindowJs.navigator.userAgent_get()\r\n```\r\n\r\n###### Renderer Taskpool\r\n\r\n```js\r\nimport { requireTaskPool } from 'electron-remote';\r\n\r\nconst myCoolModule = requireTaskPool(require.resolve('./my-cool-module'));\r\n\r\n// This method will run synchronously, but in a background BrowserWindow process\r\n// so that your app will not block\r\nlet result = await myCoolModule.calculateDigitsOfPi(100000);\r\n```\r\n\r\n## But I like Remote!\r\n\r\nRemote is super convenient! But it also has some downsides - its main downside is that its action is **synchronous**. This means that both the main and window processes will _wait_ for a method to finish running. Even for quick methods, calling it too often can introduce scroll jank and generally cause performance problems. \r\n\r\nelectron-remote is a version of remote that, while less ergonomic, guarantees that it won't block the calling thread.\r\n\r\n## Using createProxyForRemote\r\n\r\n`createProxyForRemote` is a replacement for places where you would use Electron's `executeJavaScript` method on BrowserWindow or WebView instances - however, it works a little differently. Using a new feature in ES2015 called [proxy objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), we create an object which represents the `window` object on a remote context, and all method calls get sent as messages to that remote instead of being run immediately, which feels very similar to the `remote` Electron module.\r\n\r\nThis provides a number of very important advantages:\r\n\r\n* `createProxyForRemote` uses asynchronous IPC instead of blocking\r\n* Parameters are serialized directly, so you don't have to try to build strings that can be `eval`d, which is a dangerous endeavor at best.\r\n* Calling methods on objects is far more convenient than trying to poke at things via a remote eval.\r\n\r\n#### How do I get properties if everything is a Promise tho???\r\n\r\nAstute observers will note, that getting the value of a property is always a synchronous operation - to facilitate that, any method with `_get()` appended to it will let you fetch the value for the property.\r\n\r\n```js\r\nimport { createProxyForRemote } from 'electron-remote';\r\n\r\n// myWindowJs is now a proxy object for myWindow's `window` global object\r\nconst myWindowJs = createProxyForRemote(myWindow);\r\n\r\n// Functions suffixed with _get will read a value\r\nmyWindowJs.navigator.userAgent_get()\r\n  .then((agent) => console.log(`The user agent is ${agent}`));\r\n```\r\n\r\n#### But do this first!\r\n\r\nBefore you use `createProxyForRemote`, you **must** call `initializeEvalHandler()` in the target window on startup. This sets up the listeners that electron-remote will use.\r\n\r\n#### Bringing it all together\r\n\r\n```js\r\n// In my window's main.js\r\ninitializeEvalHandler();\r\nwindow.addNumbers = (a,b) => a + b;\r\n\r\n\r\n// In my main process\r\nlet myWindowProxy = createProxyForRemote(myWindow);\r\nmyWindowProxy.addNumbers(5, 5)\r\n  .then((x) => console.log(x));\r\n  \r\n>>> 10\r\n```\r\n\r\n## Here Be Dragons\r\n\r\nelectron-remote has a number of significant caveats versus the remote module that you should definitely be aware of:\r\n\r\n* Remote values must be Serializable\r\n\r\nObjects that you return to the calling process must be serializable (i.e. you can call `JSON.stringify` on it and get a valid thing)- this means that creating Classes won't work, nor will return objects like BrowserWindows or other Electron objects. For example:\r\n\r\n```js\r\nlet myWindowProxy = createProxyForRemote(myWindow);\r\n\r\n// XXX: BAD - HTML elements aren't serializable\r\nlet obj = myWindowProxy.document.createElement('h1');\r\n```\r\n\r\n* Remote event listeners aren't supported\r\n\r\nAnything that involves an event handler isn't going to work:\r\n\r\n```js\r\n// XXX: BAD - You can't add event handlers\r\nmyWindowProxy.document.addEventListener('onBlur', (e) => console.log(\"Blur!\"));\r\n```\r\n\r\n## The Renderer Taskpool\r\n\r\nRenderer Taskpools provide an automatic way to use BrowserWindows as \"background processes\" that auto-scales based on usage, similar to Grand Central Dispatch or the .NET TPL Taskpool. This works by allowing you to provide a Module that you'd like to load in the remote processes, which will be loaded and unloaded on the fly according to demand.\r\n\r\nLet's look at the example again:\r\n\r\n```js\r\nimport { requireTaskPool } from 'electron-remote';\r\n\r\nconst myCoolModule = requireTaskPool(require.resolve('./my-cool-module'));\r\n\r\n// This method will run synchronously, but in a background BrowserWindow process\r\n// so that your app will not block\r\nlet result = await myCoolModule.calculateDigitsOfPi(100000);\r\n```\r\n\r\nBy default, `requireTaskPool` will create up to four background processes to concurrently run JS code on. As these processes become busy, requests will be queued to different processes and wait in line implicitly.\r\n\r\n##### More Dragons\r\n\r\nSince `requireTaskPool` will create and destroy processes as needed, this means that global variables or other state will be destroyed as well. You can't rely on setting a global variable and having it persist for a period of time longer than one method call.\r\n\r\n## The remote-ajax module\r\n\r\nOne module that is super useful to have from the main process is a way to make network requests using Chromium's networking stack, which correctly does things such as respecting the system proxy settings. To this end, electron-remote comes with a convenient wrapper around Rx-DOM's AJAX methods called `remote-ajax`.\r\n\r\n```js\r\nimport { requireTaskPool } from 'electron-remote';\r\n\r\nconst remoteAjax = requireTaskPool(require.resolve('electron-remote/remote-ajax'));\r\n\r\n// Result is the object that XmlHttpRequest gives you\r\nlet result = await remoteAjax.get('https://httpbin.org/get');\r\nconsole.log(result.url)\r\n\r\n>>> 'https://httpbin.org/get'\r\n```\r\n\r\nSee the documentation for [Rx-DOM](https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/modules/main-ajax/readme.md) for how these methods work.\r\n\r\nAnother method that is included is `downloadFileOrUrl`, which lets you download a file to a target:\r\n\r\n```js\r\n/**\r\n * Downloads a path as either a file path or a HTTP URL to a specific place\r\n *\r\n * @param  {string} pathOrUrl   Either an HTTP URL or a file path.\r\n * @return {string}             The contents as a UTF-8 decoded string.\r\n */\r\nfunction downloadFileOrUrl(pathOrUrl, target)\r\n```\r\n"
}