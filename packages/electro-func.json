{
  "name": "electro-func",
  "version": "2.0.0",
  "description": "A barebones functional testing framework for client-side javascript using a headless electron instance for rendering.",
  "keywords": [
    "electron",
    "testing",
    "test",
    "functional",
    "client-side",
    "functional testing",
    "headless",
    "javascript testing"
  ],
  "license": "MIT",
  "author": {
    "name": "Kim Mantas",
    "email": "kim.mantas@gmail.com",
    "url": "http://kim.mantas.me.uk"
  },
  "bin": {
    "electro-func": "./cli.js"
  },
  "directories.example": "./examples",
  "repository": {
    "type": "git",
    "url": "git+https://bitbucket.org/fyorl/electro-func.git"
  },
  "dependencies": {
    "colors": "^1.1.2",
    "chai": "^3.5.0",
    "moment": "^2.15.1",
    "electron": "^1.4.0",
    "minimist": "^1.2.0"
  },
  "gitHead": "5cdfaf43271d22069d3d410438b561090776373e",
  "homepage": "https://bitbucket.org/fyorl/electro-func#readme",
  "scripts": {},
  "_npmVersion": "3.10.3",
  "_nodeVersion": "6.6.0",
  "dist": {
    "shasum": "b810a1faa61f3fc9fc0febc018b6c8b83796bb53",
    "tarball": "http://registry.npmjs.org/electro-func/-/electro-func-2.0.0.tgz"
  },
  "versions": [
    {
      "number": "1.0.0",
      "date": "2016-11-06T18:46:31.671Z"
    },
    {
      "number": "1.0.1",
      "date": "2016-11-06T19:09:49.492Z"
    },
    {
      "number": "1.0.2",
      "date": "2016-11-07T16:55:02.847Z"
    },
    {
      "number": "1.0.3",
      "date": "2016-11-09T16:55:28.145Z"
    },
    {
      "number": "1.0.4",
      "date": "2016-11-10T16:21:31.352Z"
    },
    {
      "number": "2.0.0",
      "date": "2016-11-11T20:45:39.683Z"
    }
  ],
  "created": "2016-11-06T18:46:31.671Z",
  "modified": "2016-11-11T20:45:39.683Z",
  "lastPublisher": {
    "name": "fyorl",
    "email": "kim.mantas@gmail.com"
  },
  "owners": [
    {
      "name": "fyorl",
      "email": "kim.mantas@gmail.com"
    }
  ],
  "readme": "A barebones functional testing framework for client-side javascript using a headless electron instance for rendering.\n\nQuick Start\n===========\n\nInstall `electro-func` in your project by running the following from your project's directory:\n\n```\n$ npm install electro-func\n```\n\nAdd the test harness and your tests to the bottom of any files you want to test:\n\n```\n#!html\n<!-- index.html -->\n<body>\n\t<!-- ... -->\n\t<script src=\"node_modules/electro-func/harness.js\"></script>\n\t<script src=\"tests/example.test.js\"></script>\n</body>\n```\n\nRun your tests by running the following from your project's directory (this example runs any tests in `index.html`):\n\n```\n$ node_modules/.bin/electro-func index\n```\n\nJQuery\n======\n\nIf your project uses jQuery, you will need to add the following extra code before the `<script>` that includes jQuery in your page, i.e:\n\n```\n#!html\n<script>\n\tif (window.require) {\n\t\twindow.$ = window.jQuery = require('./js/jquery-3.1.1.min');\n\t}\n</script>\n<script src=\"js/jquery-3.1.1.min.js\"></script>\n```\n\nThe reason for this is because the jQuery library tries to detect whether it's running in a node.js environment or running in a browser environment. Because we use electron to render the pages and not an actual browser, jQuery thinks it's running in a node.js environment and doesn't add itself to the global `window` scope which any client-side javascript will be depending on.\n\nExamples\n========\n\nThe `examples/` directory contains an example of the most minimal test in the `basic/` directory while the `app/` directory contains an example of a full single-page application and its associated tests which you can use to get a better idea of how to use the framework.\n\nYou can view the examples in your browser or run them yourself. To do that, you need to install `electro-func` to the directory of the example you want to run with:\n\n```\n$ npm install\n```\n\nThen you can run the basic example with:\n\n```\n$ node_modules/.bin/electro-func\n```\n\nAnd you can run the app example with:\n\n```\n$ node_modules/.bin/electro-func index\n```\n\nAdding Tests to a Project\n============================\n\nThe following is a brief guide/tutorial that goes beyond the quick start guide and walks through adding some functional tests to an existing site's javascript.\n\nAll the code can be found in `examples/` directory under the `guide/` directory.\n\n## Project structure\n\nWe start with a website that might look like this:\n\n```\n├── css\n│   └── site.css \n├── js\n│   ├── jquery-3.1.1.min.js\n│   └── site.js\n├── img\n│   ├── bg-texture.png\n│   └── logo.png\n├── about.html\n├── example.html\n└── index.html\n```\n\nOn the site's index page, there is a form that allows the visitor to input their favourite colour and it will store this value for the next time they visit. Our `index.html` might look something like this:\n\n```\n#!html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Favourite Colour</title>\n\t<link rel=\"stylesheet\" href=\"css/site.css\">\n</head>\n<body>\n\t<div id=\"greeting\"></div>\n\t<form id=\"colour-form\">\n\t\t<label for=\"colour\">Favourite colour</label>\n\t\t<input id=\"colour\" type=\"text\">\n\t\t<button id=\"save\" type=\"button\">Save</button>\n\t</form>\n\t\n\t<script src=\"js/jquery-3.1.1.min.js\"></script>\n\t<script src=\"js/site.js\"></script>\n</body>\n</html>\n```\n\n## Code\n\nThe code that manages the loading and saving of visitors' favourite colours is in `site.js`:\n\n```\n#!js\n'use strict';\n\nconst loadFavouriteColour = () => {\n\tconst colour = localStorage['favourite-colour'];\n\tconst msg =\n\t\tcolour\n\t\t\t? 'Your favourite colour is ' + colour\n\t\t\t: \"You don't have a favourite colour yet\";\n\t$('#greeting').text(msg);\n};\n\nconst saveFavouriteColour = () => {\n\tconst colour = $('#colour').val();\n\tif (colour.length < 1) {\n\t\tlocalStorage.removeItem('favourite-colour');\n\t} else {\n\t\tlocalStorage['favourite-colour'] = colour;\n\t}\n};\n\n$('#save').click(saveFavouriteColour);\nloadFavouriteColour();\n```\n\nWe want to write some tests to make sure this code behaves as expected.\n\n## Tests\n\nWe write our tests in `tests/site.test.js`:\n\n```\n#!js\n'use strict';\n\n// Create the test suite.\n_tests.Site = {};\n\n// Clean up any saved state before each test.\n_tests.Site._before = done => {\n\tObject.keys(localStorage).forEach(key => localStorage.removeItem(key));\n\tdone();\n};\n\n_tests.Site.testLoadNoFavouriteColour = done => {\n\tloadFavouriteColour();\n\tassert.equal($('#greeting').text(), \"You don't have a favourite colour yet\");\n\tdone();\n};\n\n_tests.Site.testLoadFavouriteColour = done => {\n\tlocalStorage['favourite-colour'] = 'black';\n\tloadFavouriteColour();\n\tassert.equal($('#greeting').text(), 'Your favourite colour is black');\n\tdone();\n};\n\n_tests.Site.testSaveFavouriteColour = done => {\n\tconst click = $.Event('click');\n\t$('#colour').val('black');\n\t$('#save').trigger(click);\n\tassert.equal(localStorage['favourite-colour'], 'black');\n\tdone();\n};\n\n_tests.Site.testSaveBlankFavouriteColour = done => {\n\tconst click = $.Event('click');\n\t$('#colour').val('');\n\t$('#save').trigger(click);\n\texpect(localStorage['favourite-colour']).to.not.exist;\n\tdone();\n};\n```\n\nTests belong to suites and suites belong to the global `_tests` object which is provided by the `electro-func` framework.\n\nTo add a suite, simply create a new object on the global `_tests` object. For example, using normal property syntax:\n\n```\n#!js\n_tests.TestSuite = {};\n```\n\nOr, if you need spaces, for example, you can use dictionary syntax:\n\n```\n#!js\n_tests['A Suite of Tests'] = {};\n```\n\n**Note:** The names of tests or test suites cannot begin with an underscore ('_').\n\nTo add a test to a suite, simply add a function to your suite object with the name of the test, e.g.:\n\n```\n#!js\n_tests.TestSuite.testSomeFunction = done => {\n\tdone();\n};\n```\n\nAs with test suites, you can also use dictionary syntax:\n\n```\n#!js\n_tests.TestSuite['testing something'] = done => {\n\tdone();\n};\n```\n\nAll tests accept a single argument, `done` which is a function that must be called once the test is complete. This allows you to use callbacks and promises in your tests, e.g.:\n\n```\n#!js\n_tests.TestSuite.testTimeout = done => {\n\tsetTimeout(() => {\n\t\tassert(true);\n\t\tdone();\n\t}, 200);\n};\n```\n\nIf you forget to call `done`, your test will timeout.\n\nSee the **Advanced Usage** section for information on `_before`, `_after`, `_beforeSuite`, and `_afterSuite`.\n\n## Putting It All Together\n\nWe now have a choice on how we want to proceed: We can add the test code directly to `index.html` where it won't affect the normal functioning of the site ()except to increase page load time); or we can create our own `TestRunner.html` where we set up some special environment for running our tests in.\n\nThe choice will depend on the structure of your project. For simplicity, we will just add our tests to the index page.\n\nThe first thing we need to do, is allow jQuery to run inside electron. We add the code specified in the **JQuery** section.\n\nNext we need to add the `electro-func` harness and our test to the bottom of the index page, after all our other scripts. The index page now looks like this:\n\n```\n#!html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Favourite Colour</title>\n\t<link rel=\"stylesheet\" href=\"css/site.css\">\n</head>\n<body>\n\t<div id=\"greeting\"></div>\n\t<form id=\"colour-form\">\n\t\t<label for=\"colour\">Favourite colour</label>\n\t\t<input id=\"colour\" type=\"text\">\n\t\t<button id=\"save\" type=\"button\">Save</button>\n\t</form>\n\t\n\t<script>\n    \tif (window.require) {\n    \t\twindow.$ = window.jQuery = require('./js/jquery-3.1.1.min');\n    \t}\n    </script>\n\t\n\t<script src=\"js/jquery-3.1.1.min.js\"></script>\n\t<script src=\"js/site.js\"></script>\n\t\n\t<!-- Tests -->\n\t<script src=\"node_modules/electro-func/harness.js\"></script>\n\t<script src=\"tests/site.test.js\"></script>\n</body>\n</html>\n```\n\n## Running\n\nIn order to run the tests, we run the following command from our project's directory:\n\n```\n$ node_modules/.bin/electro-func index\n```\n\nAnd should see some similar output to the following:\n\n```\n  +------------------+\n  |    INDEX.HTML    |\n  +------------------+\n  \n  Site\n    ✔ testLoadNoFavouriteColour (2ms)\n    ✔ testLoadFavouriteColour (2ms)\n    ✔ testSaveFavouriteColour (2ms)\n    ✔ testSaveBlankFavouriteColour (2ms)\n  \n  4 passing  (8ms)\n```\n\nAdvanced Usage\n==============\n\nAside from the bare minimum required to run functional tests, `electro-func` also includes some additional features.\n\n## Debug Mode\n\nYou can pass the `--debug` flag on the command line which turns off `electron`'s headless mode. A browser window will spawn with the devtools panel open and you can use its debugging features to debug any test failures you might be having. You can rerun the tests from within the browser window by running `location.reload()` in the devtools console.\n\n## Timeout\n\nBy default, any test that takes longer than 2000ms to run will timeout and automatically fail. This is in case there are some complicated nested callbacks or promises being used such that `done` never gets called and the framework has no idea whether it can continue to the next test or not.\n\nIf some of your tests legitimately require longer than 2000ms to run, you can increase this timeout by specifying the `--timeout n` flag on the command line, where `n` is the number of milliseconds timeout you want.\n\n## Setup and Teardown\n\nThe framework provides some facility for providing setup and teardown functions to your tests. You usually want this to ensure that your page state is reset after each test and that whatever was done in one test, doesn't affect the results of a separate test.\n\nFor example, you can set a `_before` function on the test suite object in order to reset the `localStorage` before every test is run:\n\n```\n#!js\n_tests.Suite._before = done => {\n\tObject.keys(localStorage).forEach(key => localStorage.removeItem(key));\n\tdone();\n};\n```\n\nThese functions all take a single `done` argument which is a function that must be called once done.\n\n### _before\nRuns before every test in a suite.\n\n### _after\nRuns after every test in a suite.\n\n### _beforeSuite\nRuns once, before any tests in a suite are run.\n\n### _afterSuite\nRuns once, after all the tests in a suite have been run.\n"
}