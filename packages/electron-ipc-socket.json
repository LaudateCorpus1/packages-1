{
  "name": "electron-ipc-socket",
  "version": "1.2.4",
  "description": "Response-request abstraction on top of Electron IPC system.",
  "main": "lib/index.js",
  "scripts": {
    "lint": "echo eslint -c ./.eslintrc.json src",
    "test": "npm run lint && mocha --reporter spec --compilers js:babel-register --recursive test",
    "cover": "istanbul cover _mocha -- --compilers js:babel-register --recursive",
    "coveralls": "cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js  && rm -rf ./coverage",
    "clean": "rimraf lib",
    "build": "npm run test && npm run clean && babel src --out-dir lib",
    "prepublish": "npm run build"
  },
  "repository": {
    "user": "ziflex",
    "repo": "electron-ipc-socket",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/ziflex/electron-ipc-socket/tarball/master",
    "clone_url": "https://github.com/ziflex/electron-ipc-socket",
    "https_url": "https://github.com/ziflex/electron-ipc-socket",
    "travis_url": "https://travis-ci.org/ziflex/electron-ipc-socket",
    "zip_url": "https://github.com/ziflex/electron-ipc-socket/archive/master.zip",
    "api_url": "https://api.github.com/repos/ziflex/electron-ipc-socket"
  },
  "keywords": [
    "electron",
    "socket",
    "ipc",
    "communication"
  ],
  "author": {
    "name": "Tim Voronov",
    "email": "ziflex@gmail.com"
  },
  "license": "MIT",
  "homepage": "https://github.com/ziflex/electron-ipc-socket#readme",
  "dependencies": {
    "compose-class": "^1.0.0",
    "disposable-decorator": "^1.0.0",
    "disposable-mixin": "^1.0.0",
    "es6-symbol": "^3.1.0",
    "is-arguments": "^1.0.2",
    "is-error": "^2.2.1",
    "is-function": "^1.0.1",
    "is-nil": "^1.0.1",
    "is-object": "^1.0.1",
    "uuid": "^2.0.3"
  },
  "devDependencies": {
    "babel-cli": "^6.18.0",
    "babel-eslint": "^7.1.0",
    "babel-preset-es2015": "^6.16.0",
    "babel-preset-stage-0": "^6.16.0",
    "babel-register": "^6.18.0",
    "chai": "^3.5.0",
    "coveralls": "^2.11.14",
    "eslint": "^3.9.1",
    "eslint-config-airbnb": "^12.0.0",
    "eslint-plugin-import": "^2.0.1",
    "eslint-plugin-jsx-a11y": "^2.2.3",
    "eslint-plugin-mocha": "^4.7.0",
    "istanbul": "^1.0.0-alpha",
    "jsdom": "^9.8.3",
    "mocha": "^3.1.2",
    "sinon": "^1.17.6"
  },
  "gitHead": "7ec8532582b811d512925c507ee8d94b5af9dc39",
  "_npmVersion": "3.10.8",
  "_nodeVersion": "6.9.1",
  "dist": {
    "shasum": "51fdbfb7cd41122f2385bc2535aaa71892226dfe",
    "tarball": "http://registry.npmjs.org/electron-ipc-socket/-/electron-ipc-socket-1.2.4.tgz"
  },
  "versions": [
    {
      "number": "1.0.0",
      "date": "2016-11-09T01:38:55.303Z"
    },
    {
      "number": "1.1.0",
      "date": "2016-11-10T00:41:11.022Z"
    },
    {
      "number": "1.1.1",
      "date": "2016-11-10T05:43:30.820Z"
    },
    {
      "number": "1.1.2",
      "date": "2016-11-10T22:04:36.261Z"
    },
    {
      "number": "1.1.3",
      "date": "2016-11-10T22:13:12.410Z"
    },
    {
      "number": "1.2.0",
      "date": "2016-11-11T00:40:34.677Z"
    },
    {
      "number": "1.2.1",
      "date": "2016-11-11T22:05:44.139Z"
    },
    {
      "number": "1.2.2",
      "date": "2016-11-11T22:20:17.558Z"
    },
    {
      "number": "1.2.3",
      "date": "2016-11-11T23:10:05.214Z"
    },
    {
      "number": "1.2.4",
      "date": "2016-11-12T22:07:38.303Z"
    }
  ],
  "created": "2016-11-09T01:38:55.303Z",
  "modified": "2016-11-12T22:07:38.303Z",
  "lastPublisher": {
    "name": "ziflex",
    "email": "ziflex@gmail.com"
  },
  "owners": [
    {
      "name": "ziflex",
      "email": "ziflex@gmail.com"
    }
  ],
  "readme": "# electron-ipc-socket\n\n> Event based communication\n\nResponse-request abstraction on top of Electron IPC system.\n\n[![npm version](https://badge.fury.io/js/electron-ipc-socket.svg)](https://www.npmjs.com/package/electron-ipc-socket)\n[![Build Status](https://secure.travis-ci.org/ziflex/electron-ipc-socket.svg?branch=master)](http://travis-ci.org/ziflex/electron-ipc-socket)\n[![Coverage Status](https://coveralls.io/repos/github/ziflex/electron-ipc-socket/badge.svg?branch=master)](https://coveralls.io/github/ziflex/electron-ipc-socket)\n\n````sh\n    npm install --save electron-ipc-socket\n````\n\n## Motivation\n\nEvents are good, but sometimes you want something more than just 'emit and forget'.\nCurrent package provides an abstraction on top of Electron IPC system that allows you to make 'request-response' communication.\n\n## Usage\n\n### Basic\n\n````javascript\n// main-process.js\n\nimport { ipcMain, BrowserWindow } from 'electron';\nimport { Socket, Transport } from 'electron-ipc-socket';\nimport fs from 'fs';\n\nconst win = new BrowserWindow();\n\nconst socket = Socket('main-win', Transport(ipcMain, win));\n\nsocket.open();\n\nsocket.on('event:ready', () => {\n    console.log('message from rendering process');\n});\n\nsocket.on('message:read-file', (msg) => {\n    fs.readFile(msg.data(), 'utf8', (err, content) => {\n        if (err) {\n            return msg.reply(err);\n        }\n\n        return msg.reply(content);\n    })\n});\n\n````\n\n````javascript\n// renderer-process.js\n\nimport { ipcRenderer } from 'electron';\nimport { Socket } from 'electron-ipc-socket';\n\nconst socket = Socket('main-win', ipcRenderer);\n\nsocket.open();\n\nsocket.send('ready');\n\nsocket.send('read-file', './package.json', (err, content) => {\n    if (err) {\n        console.error(err);\n        return;\n    }\n\n    console.log(content);\n});\n\n````\n\n### Bridging\n\n````javascript\n// main-process.js\n\nimport { ipcMain, BrowserWindow } from 'electron';\nimport { Socket, Transport } from 'electron-ipc-socket';\nimport fs from 'fs';\n\nconst win = new BrowserWindow();\n\nconst socket = Socket('main-win', Transport(ipcMain, win));\n\nsocket.open();\n\nsocket.on('event:ready', () => {\n    console.log('message from rendering process');\n});\n\nsocket.on('message:read-file', (msg) => {\n    fs.readFile(msg.data(), 'utf8', (err, content) => {\n        if (err) {\n            return msg.reply(err);\n        }\n\n        return msg.reply(content);\n    })\n});\n\n````\n\n````javascript\n// renderer-process.js\n\nimport { ipcRenderer } from 'electron';\nimport { Socket, Bridge } from 'electron-ipc-socket';\n\nconst webview = document.getElementById('guest');\n\nconst host = Socket('main-win', ipcRenderer);\nconst guest = Socket('main-win', webview);\n\nconst bridge = Bridge(host, guest);\n\nbridge.open();\n\n````\n\n````javascript\n// webview.js\n\nimport { ipcRenderer } from 'electron';\nimport { Socket, Transport } from 'electron-ipc-socket';\n\nconst socket = Socket('main-win', Transport(ipcRenderer, {\n    send(...args) {\n        ipcRenderer.sendToHost(...args);\n    }\n}));\n\nsocket.open();\n\nsocket.send('ready');\n\nsocket.send('read-file', './package.json', (err, content) => {\n    if (err) {\n        console.error(err);\n        return;\n    }\n\n    console.log(content);\n});\n\n````\n\n## API\n\n### Socket\nProvides 'request-response' abstraction on top of Electron IPC system.\n\n#### Constructor(channel: string, transport: (Transport|IPC), settings: Settings)\n- ``channel`` channel name for isolated communication.\n- ``transport`` low-lever communication transport. Either electron IPC or instance of Transport.\n- ``settings`` set of internal settings.\n\n#### .isOpen()\nReturns a value which indicates whether the socket is open.\n\n#### .open()\nOpens a socket.\n\n#### .send(name: string [, payload: any] [, handler: Function])\nSends a message or emits an event.    \n\nIn order to send a message it needs to:\n- pass a message name\n- pass a response handler with a signature ``Function(response: any)``\n- optionally it's possible to send a payload after message name\n\nIn order to emit an event it needs to:\n- pass an event name\n- omit a response handler\n- optionally it's possible to send a payload after event name\n\n#### .on(name: string, handler: Function)\nAdds a message or an event handler.    \n\nIn order to add a message handler:\n- pass a message name with prefix ``message:``\n- pass a message handler with a signature ``Function(message: Message)``    \n\n``message`` object has 3 methods:\n- ``.type()`` returns a message type (name)\n- ``.data()`` returns a message payload\n- ``.reply([payload: any])`` responds to a request\n\n*There can be only one message handler for each message name.*\n\nIn order to add an event handler it needs to:\n- pass event name with prefix ``event:``\n- pass a message handler with a signature ``Function(payload: any)``\n\nIt is possible to add a generic handler for all messages and events by passing just either ``message`` or ``event``.\n\n#### .off(name: string [, handler: Function]])\nRemoves a message or an event handler.    \n\nIn order to remove a message handler it needs to:\n- pass a message name with prefix ``message:``\n- pass a message handler\n\nIn order to remove an event handler it needs to:\n- pass event name with prefix ``event:``\n- pass a message handler\n\nIn order to remove all event handlers for specific event it needs to omit handler.\nIn order to remove all event handler it needs to pass only ``event`` as an event name.\n\n#### .close()\nCloses a socket.\n\n#### Events\nA socket class has a set of internal events.\n\nAll handlers receives socket instance as a first argument.\n\n##### open\nFired when socket is opened\n\n##### close\nFired when socket is closed\n\n##### error\nFired when unhandled error occured. Sends an object that has properties:   \n- ``error`` error object\n- ``type`` handler type. ``message`` or ``event``\n- ``name`` event/message name.\n\n\n### Bridge\nRepresents a communication bridge between 2 sockets.\n\n#### Constructor(first: Socket, second: Socket)\n\n#### .open()\nOpens a bridge and starts delegating messages and events back and forth.\n\n#### .close()\nCloses a bridge and stops delegating messages and events back and forth.\n\n#### .dispose()\nDisposes a bridge and releases sockets.\n\n### Transport\nRepresents an wrapper for one or two Electron IPC objects.\nExposes same public API.\n\n#### Constructor(input: IPC [, output: IPC])\n- ``input`` input IPC for listening to events.\n- ``output`` output IPC for sending messages and emitting envents. Optional. Input IPC is used by default.\n\n### Settings\nSocket settings.    \nPlain javascript ojbect.\n\n- ``timeout`` request timeout.\n- ``cleanup`` clean up interval.\n"
}