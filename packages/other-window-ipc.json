{
  "name": "other-window-ipc",
  "version": "1.2.2",
  "description": "IPC between windows for Electron",
  "main": "other-window-ipc.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "user": "greggman",
    "repo": "other-window-ipc",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/greggman/other-window-ipc/tarball/master",
    "clone_url": "https://github.com/greggman/other-window-ipc",
    "https_url": "https://github.com/greggman/other-window-ipc",
    "travis_url": "https://travis-ci.org/greggman/other-window-ipc",
    "zip_url": "https://github.com/greggman/other-window-ipc/archive/master.zip",
    "api_url": "https://api.github.com/repos/greggman/other-window-ipc"
  },
  "keywords": [
    "ipc",
    "electron",
    "window"
  ],
  "files": [
    "other-window-ipc.js",
    "lib"
  ],
  "author": {
    "name": "Gregg Tavares"
  },
  "license": "MIT",
  "homepage": "https://github.com/greggman/other-window-ipc#readme",
  "devDependencies": {
    "electron": "^1.4.4"
  },
  "dependencies": {
    "debug": "^2.2.0"
  },
  "gitHead": "51b17c69a3b60d06a231dea8ef25d2a8da9bf95d",
  "_npmVersion": "3.10.9",
  "_nodeVersion": "4.6.1",
  "dist": {
    "shasum": "68256d4f8dc1834127c8e2d9042cc02ebe752196",
    "tarball": "http://registry.npmjs.org/other-window-ipc/-/other-window-ipc-1.2.2.tgz"
  },
  "versions": [
    {
      "number": "0.0.1",
      "date": "2016-10-21T18:36:33.234Z"
    },
    {
      "number": "0.0.2",
      "date": "2016-11-01T17:21:46.631Z"
    },
    {
      "number": "1.0.0",
      "date": "2016-11-06T12:58:07.399Z"
    },
    {
      "number": "1.0.1",
      "date": "2016-11-06T13:00:36.960Z"
    },
    {
      "number": "1.1.0",
      "date": "2016-11-06T19:23:05.429Z"
    },
    {
      "number": "1.2.0",
      "date": "2016-11-07T15:06:25.034Z"
    },
    {
      "number": "1.2.1",
      "date": "2016-11-07T15:13:50.773Z"
    },
    {
      "number": "1.2.2",
      "date": "2016-11-07T23:52:57.019Z"
    }
  ],
  "created": "2016-10-21T18:36:33.234Z",
  "modified": "2016-11-07T23:52:57.019Z",
  "lastPublisher": {
    "name": "greggman",
    "email": "github@greggman.com"
  },
  "owners": [
    {
      "name": "greggman",
      "email": "github@greggman.com"
    }
  ],
  "readme": "#Other-Window-IPC\n\nThere's probably an easier way to do this so if so please tell me but\nhere's a solution just in case.\n\nI needed/wanted to be able to pass messages between Electron windows.\n\nSo, this module.\n\n## Usage\n\nThere are `IPChannels` and `IPCSteams`. You can think of an `IPCChannel`\njust like an http listener on a port except instead of numbers we use strings.\n\nAny window can have multiple `IPCChannel`s. An `IPCChannel`s sole purpose\nis to listen for connections. Connections are `IPCStreams`\n\nIn browser process\n\n    const otherWindowIPC = require('other-window-ipc');\n\nNote you must have this even if you don't use it in the browser\nprocess.\n\nIn renderer or browser process\n\n*   For a process that just wants to listen for other processes\n\n        const otherWindowIPC = require('other-window-ipc');\n\n        const channelName = \"blarg\";\n        const ipcChannel = otherWindowIPC.createChannel(channelName);\n\n        ipcChannel.on('connect', (stream) => {\n\n            // listen for events on stream\n            steam.on('moo', (someArg, someOtherArg) => {\n              console.log(\"got moo:\", someArg, someOtherArg);\n            });\n\n            // send something to other side\n            stream.send('foobar', \"foo\", \"bar\");\n        });\n\n*   For a process that wants to open a stream on a channel\n\n        const otherWindowIPC = require('other-window-ipc');\n\n        const channelName = \"blarg\";\n        otherWindowIPC.createChannelStream(channelName)\n        .then(stream => {\n\n            // listen for events on stream\n            steam.on('foobar', (someArg, someOtherArg) => {\n              console.log(\"got foobar:\", someArg, someOtherArg);\n            });\n\n            // send something to other side\n            stream.send('moo', \"said\", \"the cow\");\n\n        })\n        .catch(err => {\n          console.log(\"err\");\n        });\n\nNote `send` works the same as the standard `EventEmitter.emit` in that you\ncan pass muliple arguments, etc..\n\n    stream.send(type, arg2, arg3, ...);\n\nAnd listeners will receive those arguments\n\n## Disconnecting\n\nTo close a stream call `stream.close`. The corresponding stream on the\nother side will receive `disconnect` event. This is the only hardcoded\nevent.  In other words\n\n    stream.on('disconnect', () => {\n       // stream.close was called on the other side\n    });\n\n## API / Usage\n\n    const otherWindowIPC = require('./other-window-ipc');\n\nThere are only 2 functions on `otherWindowIPC`\n\n#### `otherWindowIPC.createChannel(channelId)`\n\nreturns an `IPCChannel` and registers the channel.\n\n#### `otherWindowIPC.createChannelStream(channelId)`\n\nreturns a `Promise` that resolves to an `IPCStream` once\nit has connected to the channel. Rejects if there is\nno such channel\n\n### `IPCChannel`\n\nThis is returned by `createChannel`. It is an `EventEmitter`\nthat emits just one event `connect` that gets passed an `IPCStream`.\n\n#### `ipcChannel.close()`\n\nUnregisters the channel. Note: Streams created for that channel\nwill still be open and functioning. Closing the channel basically\njust frees the channelId to be used to create a new channel\n\n### `IPCStream`\n\nThis is created by calling `createChannelStream` or is emitted\nin the `connect` event on an `IPCChannel`.\n\nIt is an `EventEmitter`. Any arguments passed to `send` will\narrive at the corresponding `IPCStream` on the other side.\nArguments must be `JSON.stringify`able.\n\nOtherwise see [`EventEmitter` for docs](https://nodejs.org/api/events.html#events_class_eventemitter)\non adding and removing listeners.\n\n#### `ipcStream.send(type, ...args)`\n\nThis is just like the standard `EventEmitter.emit` except\nthe event will appear on the corresponding `IPCStream` on the\nother side.\n\n#### `ipcStream.close()`\n\nCloses the stream. The corresponding `IPCStream` on the other side\nwill receive a `disconnect` event.\n\n## Install\n\n    npm install other-window-ipc --save\n\n## Example\n\nYou can see a working example in the example folder\n\n    git clone https://github.com/greggman/other-window-ipc.git\n    npm install\n    ./node_electron/.bin/electron example/main.js\n\n## Changelog\n\n*   1.2.0\n\n    *   Allow main/browser process to also create channels\n        and streams\n\n*   1.1.0\n\n    *   Keep channel to target mapping in main process\n\n        This means you no longer need a to know the id\n        of the window. Just call `createChannel` and pass\n        a name. Then use that name in `createChannelStream`\n\n*   1.0.1\n\n    *   Bug fixes\n\n*   1.0.0\n\n    *   Change to use channels and streams so\n        you can easily have multiple streams per\n        channel\n\n*   0.0.1\n\n    Initial release\n\n## To Do\n\n*   Make `IPCChannel.close` close all streams?\n\n    Currently all `channel.close` does is unregister the channel.\n    All streams are still open and will continue to funciton.\n\n    Maybe that's fine. The channel itself is just a way to\n    accept streams. If you want to close all your streams\n    then keep your own list of streams. Probably much easier\n    than having channel keep track of streams.\n\n*   Should it not make instances?\n\n    Currently `require('other-window-ipc')` makes an instance\n    of `IPCManager` and returns that instance. It's now ready\n    to use. Because `IPCManager` needs to use global services\n    like `electron.ipcMain` and `electron.ipcRenderer` there\n    doesn't seem to be much point in having multiple instances.\n\n    On the other hand you could pass in some kind of prefix\n    that would allow multiple `IPCManager`s to function.\n    Not really sure what the point would be. Could also\n    pass in an implemention of `ipcMain` or `ipcRenderer`.\n\n    If someone really needs this we file an issue and explain.\n    It would be a breaking change.\n\n*   Abstract to the point where you can run channels on top of\n    channels.\n\n    You never know when you're going to need to run streams\n    over a stream. I probably won't try to do this until I\n    run into the use case.\n\n"
}