{
  "name": "ethereum-blocks",
  "version": "1.0.3",
  "description": "Process blocks from Ethereum client nodes robustly. Catch-up on restart, auto-reconnect to node, etc.",
  "main": "dist/ethereumBlocks.js",
  "scripts": {
    "build": "mkdir -p dist && babel src/index.js > dist/ethereumBlocks.js",
    "test": "npm run build && mocha --timeout 180000 --ui exports --reporter spec test/*.test.js",
    "test-coverage": "npm run build && istanbul cover _mocha -- --timeout 180000 --ui exports --reporter spec test/*.test.js"
  },
  "repository": {
    "user": "hiddentao",
    "repo": "ethereum-blocks",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/hiddentao/ethereum-blocks/tarball/master",
    "clone_url": "https://github.com/hiddentao/ethereum-blocks",
    "https_url": "https://github.com/hiddentao/ethereum-blocks",
    "travis_url": "https://travis-ci.org/hiddentao/ethereum-blocks",
    "zip_url": "https://github.com/hiddentao/ethereum-blocks/archive/master.zip",
    "api_url": "https://api.github.com/repos/hiddentao/ethereum-blocks"
  },
  "keywords": [
    "ethereum",
    "blockchain",
    "processor",
    "reconnect",
    "restart",
    "web3"
  ],
  "author": {
    "name": "Ramesh Nair",
    "email": "ram@hiddentao.com"
  },
  "license": "MIT",
  "homepage": "https://github.com/hiddentao/ethereum-blocks#readme",
  "devDependencies": {
    "babel-cli": "^6.14.0",
    "babel-plugin-rename-umd-globals": "0.0.4",
    "babel-plugin-transform-es2015-modules-umd": "^6.12.0",
    "babel-preset-es2015": "^6.14.0",
    "bluebird": "^3.4.6",
    "chai": "^3.5.0",
    "co-mocha": "^1.1.3",
    "genomatic": "^1.0.0",
    "geth-private": "^1.5.1",
    "istanbul": "^0.4.5",
    "lodash": "^4.15.0",
    "mocha": "^3.0.2",
    "sinon": "^1.17.5",
    "sinon-chai": "^2.8.0",
    "web3": "^0.17.0-alpha"
  },
  "gitHead": "b3739fcae8bbad3e0ea712515fa433541bb50662",
  "_npmVersion": "3.9.3",
  "_nodeVersion": "4.4.5",
  "dist": {
    "shasum": "63076201fa43402119feb9c5eee2d49fbca5febe",
    "tarball": "http://registry.npmjs.org/ethereum-blocks/-/ethereum-blocks-1.0.3.tgz"
  },
  "versions": [
    {
      "number": "1.0.0",
      "date": "2016-09-07T11:42:06.689Z"
    },
    {
      "number": "1.0.1",
      "date": "2016-09-12T07:07:50.439Z"
    },
    {
      "number": "1.0.2",
      "date": "2016-09-13T18:26:52.287Z"
    },
    {
      "number": "1.0.3",
      "date": "2016-09-14T06:23:08.184Z"
    }
  ],
  "created": "2016-09-07T11:42:06.689Z",
  "modified": "2016-09-14T06:23:08.184Z",
  "lastPublisher": {
    "name": "hiddentao",
    "email": "ram@hiddentao.com"
  },
  "owners": [
    {
      "name": "hiddentao",
      "email": "ram@hiddentao.com"
    }
  ],
  "readme": "# ethereum-blocks\n\n[![Build Status](https://secure.travis-ci.org/hiddentao/ethereum-blocks.png?branch=master)](http://travis-ci.org/hiddentao/ethereum-blocks) [![NPM module](https://badge.fury.io/js/ethereum-blocks.png)](https://badge.fury.io/js/ethereum-blocks) [![Twitter URL](https://img.shields.io/twitter/url/http/shields.io.svg?style=social&label=Follow&maxAge=2592000)](https://twitter.com/hiddentao)\n\nProcess blocks from an Ethereum [web3](https://github.com/ethereum/web3.js/) instance robustly.\n\nThis library uses [web3.eth.filter](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethfilter) to listen for the latest blocks on a \nchain. When a block is received all registered handlers are invoked to perform any \nrequired processing on the block data.\n\nFeatures:\n\n* Can *catch up* on all missed blocks when restarted\n* Detects if connection has dropped and waits until re-established\n* Processing handlers can be asynchronous\n* Errors are gracefully handled\n* Customizable logging, can be turned on/off at runtime\n* Works with any [web3](https://github.com/ethereum/web3.js/) instance\n* No dependencies - works in Node, Electron apps and browsers\n* Automated [tests](https://travis-ci.org/hiddentao/ethereum-blocks)\n\n## Installation\n\n```shell\n$ npm install ethereum-blocks\n```\n\n## Usage\n\n```js\nimport Web3 from 'web3';\nimport EthereumBlocks from 'ethereum-blocks';\n\nconst web3 = new Web3(/* connect to running Geth node */);\n\n// create a new instance\nconst blocks = new EthereumBlocks({ web3: web3 });\n\n// register a handler called \"myHandler\"\nblocks.registerHandler('myHandler', (eventType, blockId, data) => {\n  switch (eventType) {\n    case 'block':\n      /* data = result of web3.eth.getBlock(blockId) */\n      console.log('Block id', blockId);\n      console.log('Block nonce', data.nonce);\n      break;\n    case 'error':\n      /* data = Error instance */\n      console.error(data);\n      break;\n  }\n});\n\n// start the block processor\nblocks.start().catch(console.error);\n```\n\n### Starting and stopping\n\nThe `start()` and `stop()` methods are used for starting and stopping the block processor. Both are asynchronous and return `Promise` objects which resolve to a boolean indicating whether there \nwas a change of state.\n\nStarting it:\n\n```js\nblocks.start()\n.then((started) => {\n  console.log( started ? 'Started' : 'Already running');\n  \n  console.log( blocks.isRunning ); /* true */\n})\n.catch((err) => {\n  /* error */\n\n  console.log( blocks.isRunning ); /* false */  \n})\n```\n\nStopping it:\n\n```js\nblocks.stop()\n.then((stopped) => {\n  console.log( stopped ? 'Stopped' : 'Was not running');\n  \n  console.log( blocks.isRunning ); /* false */\n})\n.catch((err) => {\n  /* error */\n})\n```\n\nAs shown above, the `isRunning` property can be used to check the current status of the processor at any point in time.\n\n\n### Catching up with missed blocks\n\nIf you are re-starting the block processor after having previously stopped it \n(e.g. if your app restarted) then it is useful to be able to *catch up* on any \nblocks you may have missed in the intervening period. \n\nTo do this you first need the id/number of the last block which got processed. \nThis can be obtained at any time using the `lastBlock` property. You could store \nthis value in storage for use later on:\n\n```js\nwindow.localStorage.set('lastBlock', blocks.lastBlock);\n```\n\nThen next time your app starts up you can retrieve this value and tell the \nblock processor to process all blocks which came after this one up until \nthe current block, before then watching for new blocks:\n\n```js\nconst lastBlockProcessed = window.localStorage.get('lastBlock');\n\nblocks.start({\n  catchupFrom: lastBlockProcessed ? Number(lastBlockProcessed) : null,\n});\n```\n\nNew incoming blocks will be added to the processing queue AFTER all the blocks from the `catchupFrom` block until the current one. \n\n### Handlers\n\nHandlers are functions which get passed the block data in order to do any actual processing needed. To add and remove them:\n\n\n* `registerHandler(id: String, fn: Function)` - an `id` is required just so that the handler can be referred to in log messages. The `fn` handler function should have the signature `(eventType, blockId, data)`:\n  * `eventType` - {String} The event type (either \"block\" or \"error\")\n  * `blockId` - {String} Id of block.\n  * `data` - {Object} Block data or error object.\n* `deregisterHandler(id: String)` - the `id` must be the same one that you passed in to the registration call.\n\n*Note: If you call `registerHandler` with the same `id` more than once then the handler function sent in the latest call will be the one which gets invoked.*\n\nIf a handler function returns a `Promise` then it is treated as an asynchronous function. You can register both synchronous and asynchronous handlers with the same block processor. Processing on a given block is only considered complete when all handlers have finished executing (asynchronous or otherwise).\n\n*Note: If a handler throws an error it will be caught and logged, but the other registered handlers will still get executed.*\n\n\n### Logger\n\nBy default internal logging is silent. But you can turn on logging at any time by setting the `logger` property:\n\n```js\nblocks.logger = console;\t/* log everything to console */\n```\n\nThe supplied logger object must have 3 methods: `info`, `warn` and `error`. If any one of these methods isn't provided then the built-in method (i.e. silent method) get used. For example:\n\n```js\n// let's output only the error messages\nblocks.logger = {\n\terror: console.error.bind(console)\n}\n```\n\n### Handling node connection failures\n\nIf the web3 connection to the client node fails (e.g. because the node crashes) then the block processor is intelligent enough to detect this and wait for the connection to be re-established before resuming processing.\n\nTo check to see if the connection is active use the `isConnected` property. For example, let's say we called `start()` and the connection to the node then went down we would have:\n\n```js\nconsole.log( blocks.isRunning );  /* true */\nconsole.log( blocks.isConnected );\t/* false */\n```\n\nThe processor will check every `connectionCheckInterval` milliseconds to see if the connection has been established. You can get or set this property at runtime to check more or less often:\n\n```js\nconsole.log( blocks.connectionCheckInterval );  /* 5000 */\n\nblocks.connectionCheckInterval = 100; /* change it to check every 100ms */\n```\n\n### Processing loop interval\n\nYou can change set how often the processing loop should run using the `loopInterval` property. This is measured in milliseconds and is 5000 by default (i.e. 5 seconds):\n\n```js\nconsole.log( blocks.loopInterval );  /* 5000 */\n\nblocks.loopInterval = 100; /* run the processing loop every 100ms */\n```\n\n\n### Browser usage\n\nIf you are not using a packaging manager and are instead importing [ethereumBlocks.js](dist/ethereumBlocks.js) directly then the class is exposed on the global object as `EthereumBlocks`. Thus, in the browser window context you would use it like this:\n\n```js\nconst blocks = new window.EthereumBlocks({ web3: web3 });\n```\n\n## Development\n\nTo build and run the tests:\n\n```shell\n$ npm install\n$ npm test\n```\n\n\n## Contributions\n\nContributions welcome - see [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## License\n\nMIT - see [LICENSE.md](LICENSE.md)\n\n"
}