{
  "name": "ethereum-contracts",
  "version": "1.0.0",
  "description": "Robust Ethereum contracts wrapper for easier deployment, method invocation and automatic type conversion.",
  "main": "dist/ethereumContracts.js",
  "scripts": {
    "build": "mkdir -p dist && babel --out-file dist/ethereumContracts.js src/index.js",
    "test": "npm run build && mocha --timeout 180000 --ui exports --reporter spec test/*.test.js",
    "test-coverage": "npm run build && istanbul cover _mocha -- --timeout 180000 --ui exports --reporter spec test/*.test.js"
  },
  "repository": {
    "user": "hiddentao",
    "repo": "ethereum-contracts",
    "host": "github.com",
    "branch": "master",
    "apiHost": "api.github.com",
    "tarball_url": "https://api.github.com/repos/hiddentao/ethereum-contracts/tarball/master",
    "clone_url": "https://github.com/hiddentao/ethereum-contracts",
    "https_url": "https://github.com/hiddentao/ethereum-contracts",
    "travis_url": "https://travis-ci.org/hiddentao/ethereum-contracts",
    "zip_url": "https://github.com/hiddentao/ethereum-contracts/archive/master.zip",
    "api_url": "https://api.github.com/repos/hiddentao/ethereum-contracts"
  },
  "keywords": [
    "ethereum",
    "blockchain",
    "contract",
    "solidity",
    "web3"
  ],
  "author": {
    "name": "Ramesh Nair",
    "email": "ram@hiddentao.com"
  },
  "license": "MIT",
  "homepage": "https://github.com/hiddentao/ethereum-contracts#readme",
  "devDependencies": {
    "babel-cli": "^6.14.0",
    "babel-plugin-rename-umd-globals": "0.0.4",
    "babel-plugin-transform-es2015-modules-umd": "^6.12.0",
    "babel-preset-es2015": "^6.14.0",
    "bluebird": "^3.4.6",
    "chai": "^3.5.0",
    "co-mocha": "^1.1.3",
    "genomatic": "^1.0.0",
    "geth-private": "^1.5.1",
    "istanbul": "^0.4.5",
    "lodash": "^4.15.0",
    "mocha": "^3.0.2",
    "shelljs": "^0.7.4",
    "sinon": "^1.17.5",
    "sinon-chai": "^2.8.0",
    "solc": "^0.4.1",
    "web3": "^0.17.0-alpha"
  },
  "gitHead": "1d613a26570cc44a38028a943ded0eb098adce32",
  "_npmVersion": "3.9.3",
  "_nodeVersion": "4.4.5",
  "dist": {
    "shasum": "149ca119aa2d0680f14d657f3d61b1aeb587bb44",
    "tarball": "http://registry.npmjs.org/ethereum-contracts/-/ethereum-contracts-1.0.0.tgz"
  },
  "versions": [
    {
      "number": "1.0.0",
      "date": "2016-09-12T07:36:57.050Z"
    }
  ],
  "created": "2016-09-12T07:36:57.050Z",
  "modified": "2016-09-12T07:36:57.050Z",
  "lastPublisher": {
    "name": "hiddentao",
    "email": "ram@hiddentao.com"
  },
  "owners": [
    {
      "name": "hiddentao",
      "email": "ram@hiddentao.com"
    }
  ],
  "readme": "# ethereum-contracts\n\n[![Build Status](https://secure.travis-ci.org/hiddentao/ethereum-contracts.png?branch=master)](http://travis-ci.org/hiddentao/ethereum-contracts) [![NPM module](https://badge.fury.io/js/ethereum-contracts.png)](https://badge.fury.io/js/ethereum-contracts) [![Twitter URL](https://img.shields.io/twitter/url/http/shields.io.svg?style=social&label=Follow&maxAge=2592000)](https://twitter.com/hiddentao)\n\nEthereum contracts wrapper which makes it easier to deploy contracts to the \nblockchain and invoke their methods.\n\nFeatures:\n\n* Automatically [converts](#type-conversions) method arguments and return values according to types in [contract ABI](https://github.com/ethereum/wiki/wiki/Solidity,-Docs-and-ABI).\n* Auto-fetches transaction receipts for `sendTransaction` calls.\n* `Promise`-ified asynchronous interface for easy use.\n* Errors are gracefully handled\n* Customizable logging, can be turned on/off at runtime\n* Works with any [web3](https://github.com/ethereum/web3.js/) instance\n* No dependencies - works in Node, Electron apps and browsers\n* Automated [tests](https://travis-ci.org/hiddentao/ethereum-contracts)\n\n## Installation\n\n```shell\n$ npm install ethereum-contracts\n```\n\n## Usage\n\nBasic contract deployment:\n\n```js\nimport Web3 from 'web3';\nimport solc from 'solc';\nimport { ContractFactory } from 'ethereum-contracts';\n\nconst web3 = new Web3(/* connect to running Geth node */);\n\n// create a new factory\nconst factory = new ContractFactory({\n  web3: web3,\n  /* Account from which to make transactions */\n  account: web3.eth.coinbase,\n  /* Default gas to use for any transaction */\n  gas: 500000 \n});\n\n// compile our contract\nconst soliditySrc = readFile(...);\nconstant contractData = Object.values(solc.compile(soliditySrc, 1).contracts).pop();\n\n// get Contract instance\nconst contract = factory.make({\n  contract: contractData,\n});\n\n// Deploy it!\ncontract.deploy()\n  .then((contractInstance) => {\n    // deployed ok!\n  })\n  .catch(console.error);\n```\n\nThe `deploy()` method returns a `Promise` which resolves to an instance of \n`ContractInstance` (`require('ethereum-contracts').ContractInstance`) \nrepresenting an instance of the contract at its deployed address. \n\nThis instance exposes an API which by which you can methods within the \ndeployed contract.\n\n**Note: If you get an error stating that your account is locked then you \nmay need to unlock it first using [`web3.personal.unlockAccount()`](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#personalunlockaccount).**\n\n### Invoking contract methods locally\n\nSuppose we have a simple contract code:\n\n```sol\ncontract Local {\n  function getOne() returns (uint8, string) {\n    return (123, \"ok\");\n  }\n}\n```\n\nWe can call `getOne()` on the local blockchain without having to send out a \ntransaction:\n\n```js\nconsole.log( contractInstance.localCall('getOne') );\n\n/* [ 123, \"ok\" ] */\n```\n\n### Invoking contract methods via Transaction\n\nLet's say our contract is:\n\n```sol\ncontract Counter {\n  uint8 val;\n  \n  function increment(){\n    val += 1;\n  }\n}\n```\n\nWe can invoke `increment()` by sending a transaction to the blockchain, which returns a `Promise`:\n\n```js\ncontractInstance.sendCall('increment')\n.then((txReceipt) => {\n  // do something\n})\n.catch(console.error);\n```\n\nThe `txReceipt` object returned above is the result of the call to \n`web3.eth.getTransactionReceipt()` for the corresponding transaction.\n\n### Passing in method arguments\n\nLet's say we our contract is:\n\n```sol\ncontract Counter {\n  uint8 val;\n  string label;\n  \n  function increment(uint8 amount, string newLabel) {\n    val += amount;\n    label = newLabel;\n  }\n  \n  function isBigger(uint8 check) returns (bool) {\n    return (check > val) ? true : false;\n  }\n}\n```\n\nWe can pass in arguments for both local calls and transaction calls as \nkey-value pairs (i.e. `Object`):\n\n```js\n// local\nlet result = contractInstance.localCall('isBigger', {\n  check: 5\n})\n\n// transaction\ncontractInstance.sendCall('increment', {\n  amount: 10,\n  newLabel: 'hello world'\n});\n```\n\n### Override account and gas\n\nWhether deploying a contract or calling a method via transaction, the gas value \nand  account from which the transaction is sent can be overridden on a per-call basis:\n\n```js\nimport { Contract } from 'ethereum-contracts';\n\ncontract = new Contract({\n  web3: web3,\n  contract: contractData,\n  account: web3.eth.coinbase,\n  gas: 500000\n})\n\ncontract.deploy({}, {\n  /* override account */\n  account: '0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444',\n})\n.then((contractInstance) => {\n  return contractInstance.sendCall('increment', {}, {\n    /* override gas */\n    gas: 100000\n  });\n})\n```\n\n### Browser usage\n\nIf you are not using a packaging manager and are instead importing [ethereumContracts.js](dist/ethereumContracts.js) directly then the class is exposed on the global object as `EthereumContracts`. Thus, in the browser window context you would use it like this:\n\n```js\nconst contractFactory = new window.EthereumContracts.ContractFactory({\n  web3: web3,\n  account: web3.eth.coinbase,\n  gas: 500000\n});\n```\n\n## Type conversions\n\n\n\nWhen passing in method arguments the wrapper will try to type-cast each \nargument to the required target type as defined in the contract ABI.\n\nSpecifically, here is what it does for each type:\n\n* `int/uint, int8/uint8, ..., int256/uint256` - input argument is converted to \na number and then checked to ensure it is within the accepted range of numbers for the given type's boundaries.\n*Note that `Date` instances get auto-converted to their millisecond representations.*\n* `string` - input argument is converted to a string.\n* `bool` - if input argument is `0, false, \"false\", or \"\"` it is passed on as \n`false` else it is passed on as `true`.\n* `address` - if input argument is a number it is converted to a hex \nrepresentation with enough padding to ensure it is a valid address. Otherwise it\nis string-ified and checked using `web3.isAddress()`.\n* `byte, bytes, bytes, ..., bytes32` - input argument is converted to hex \nusing `web3.toHex()`.\n\nFor return values, the logic just ensures that `int/uint` values are returned \nas actual numbers and not `BigNumber` instances (as is usually returned by web3).\n\n**Example**\n\nLet's say our contructor has:\n\n```sol\ncontract Test {\n  constructor(uint256 val, bool flag, address addr) {}\n}\n```\n\nIf we deploy with the following arguments...\n\n```js\nthis.contract.deploy({\n  val: new Date(2016,0,1,5,30,22),\n  flag: 'false',\n  addr: 234234\n});\n```\n\n...the actual values passed to the constructor will be:\n\n```\n(1451597422000, false, '0x00000000000000000000000000000000000392fa')\n```\n\n\n\n\n\n## Development\n\nTo build and run the tests:\n\n```shell\n$ npm install\n$ npm test\n```\n\nTo run tests with coverage:\n\n```shell\n$ npm run test-coverage\n```\n\n\n## Contributions\n\nContributions welcome - see [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## License\n\nMIT - see [LICENSE.md](LICENSE.md)\n\n"
}